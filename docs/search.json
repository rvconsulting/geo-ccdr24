[
  {
    "objectID": "supporting-materials/geo-microsimulation.html",
    "href": "supporting-materials/geo-microsimulation.html",
    "title": "Georgia CCDR Microsimulation",
    "section": "",
    "text": "In this calculation file, we “age” the Georgian household survey according to demographic projections and different macroeconomic scenarios to explore the impact of climate-related risks and policy measures on the consumption expenditure distribution. It is part of a larger project with all background contributions to Georgia’s CCDR, available in this repository.\n\n# Georgia administrative level 1 shapefile\nadm1 &lt;- sf::read_sf(\"data/gis/geo-adm1.shp\") |&gt; \n  dplyr::select(ADM1_PCODE, ADM1_EN, ADM1_KA, geometry) |&gt; \n  dplyr::arrange(ADM1_PCODE)\n\ntmap::tm_shape(adm1)+\n  tmap::tm_fill(\"ADM1_EN\", legend.show = FALSE, palette = \"Set1\") +\n  tmap::tm_text(\"ADM1_EN\", size = 0.65, auto.placement = T, col = \"black\")+\n  tmap::tm_layout(frame = F)\n\n\n\n\n\n\n\nFigure 1: Map of Georgia at administrative level 1\n\n\n\n\n\nAs a convention, code is presented in the following format in this guide:\n\n# Some comment that is not evaluated by R\nsome_variable &lt;- some_function(some_object, some_parameter = TRUE)\n\nWe assume that the reader has created an Rstudio project and is familiar with basic R functions. Within that project we recommend the following file structure:\n#| eval: false\nroot/\n├── supporting-materials\n│   ├── my_script.R\n|   └── my_script.qmd\n|   └── my_script.do\n├── data/\n|   ├── my_data.sav\n|   ├── my_data.dta\n|   └── my_data.csv\n└── output\n    ├── my_output1.csv\n    └── my_output2.xlsx\nUsing RStudio project makes it possible to not use setwd() to establish the root directory and refer to subdirectories in a relative manner, making interoperability easier within teams and not hard coding a particular computer’s file structure into the code. If you are not using RStudio, just add setwd(r'(C:\\My\\path\\to\\project\\root)') at the beginning of your coding session.",
    "crumbs": [
      "Home",
      "Supporting materials",
      "Georgia CCDR Microsimulation"
    ]
  },
  {
    "objectID": "supporting-materials/geo-microsimulation.html#introduction",
    "href": "supporting-materials/geo-microsimulation.html#introduction",
    "title": "Georgia CCDR Microsimulation",
    "section": "",
    "text": "In this calculation file, we “age” the Georgian household survey according to demographic projections and different macroeconomic scenarios to explore the impact of climate-related risks and policy measures on the consumption expenditure distribution. It is part of a larger project with all background contributions to Georgia’s CCDR, available in this repository.\n\n# Georgia administrative level 1 shapefile\nadm1 &lt;- sf::read_sf(\"data/gis/geo-adm1.shp\") |&gt; \n  dplyr::select(ADM1_PCODE, ADM1_EN, ADM1_KA, geometry) |&gt; \n  dplyr::arrange(ADM1_PCODE)\n\ntmap::tm_shape(adm1)+\n  tmap::tm_fill(\"ADM1_EN\", legend.show = FALSE, palette = \"Set1\") +\n  tmap::tm_text(\"ADM1_EN\", size = 0.65, auto.placement = T, col = \"black\")+\n  tmap::tm_layout(frame = F)\n\n\n\n\n\n\n\nFigure 1: Map of Georgia at administrative level 1\n\n\n\n\n\nAs a convention, code is presented in the following format in this guide:\n\n# Some comment that is not evaluated by R\nsome_variable &lt;- some_function(some_object, some_parameter = TRUE)\n\nWe assume that the reader has created an Rstudio project and is familiar with basic R functions. Within that project we recommend the following file structure:\n#| eval: false\nroot/\n├── supporting-materials\n│   ├── my_script.R\n|   └── my_script.qmd\n|   └── my_script.do\n├── data/\n|   ├── my_data.sav\n|   ├── my_data.dta\n|   └── my_data.csv\n└── output\n    ├── my_output1.csv\n    └── my_output2.xlsx\nUsing RStudio project makes it possible to not use setwd() to establish the root directory and refer to subdirectories in a relative manner, making interoperability easier within teams and not hard coding a particular computer’s file structure into the code. If you are not using RStudio, just add setwd(r'(C:\\My\\path\\to\\project\\root)') at the beginning of your coding session.",
    "crumbs": [
      "Home",
      "Supporting materials",
      "Georgia CCDR Microsimulation"
    ]
  },
  {
    "objectID": "supporting-materials/geo-microsimulation.html#preamble",
    "href": "supporting-materials/geo-microsimulation.html#preamble",
    "title": "Georgia CCDR Microsimulation",
    "section": "2 Preamble",
    "text": "2 Preamble\nWe start with a clean environment, making sure that any objects from a previous session are not present. We take this opportunity to keep our country ISO code in a variable iso in case we need it later.\n\n# Clean workspace\nrm(list = ls())\n\n# Georgia country ISO code\niso &lt;- \"GEO\"\n\n# Survey year\nsurvey_year &lt;- 2023\n\n# Exchange rate USD per GEL\ner &lt;- 0.37\n\n# Years of interest for our macroeconomic scenario analysis\nanalysis_years &lt;- c(2030, 2050)\n\nWe call the appropriate libraries.\nRather than calling our libraries as we go, we will make sure we have everything we need from the beginning.\n\nlibrary(tidyverse) # includes dplyr, ggplot2, purr...\nlibrary(haven)     # to read SPSS and Stata datasets\nlibrary(readxl)    # to read from MS-Excel\nlibrary(openxlsx)  # to write to MS-Excel.\nlibrary(gt)        # pretty tables\nlibrary(car)       # companion to applied regression\nlibrary(modelr)    # regression models\n#library(anesrake)  \n# Raking reweighting but we don't load it, because \n# it changes the meaning of summarize from dplyr, \n# so we use the form anesrake::anesrake() when using it.\n#library(ebal)      # Entropy reweighting (not used)\nlibrary(janitor)   # pretty subtotals\nlibrary(broom)     # More regressions\nlibrary(zoo)       # Calculate moving window average and max value\n# library(ineq) # Inequality measures\n# library(acid)\n\n# Geopackages\nlibrary(sf)        # to read and write shapefile maps\nlibrary(terra)     # to perform geocalculations\nlibrary(tmap)      # for static and interactive maps",
    "crumbs": [
      "Home",
      "Supporting materials",
      "Georgia CCDR Microsimulation"
    ]
  },
  {
    "objectID": "supporting-materials/geo-microsimulation.html#datasets",
    "href": "supporting-materials/geo-microsimulation.html#datasets",
    "title": "Georgia CCDR Microsimulation",
    "section": "3 Datasets",
    "text": "3 Datasets\nWe then load the datasets that we need for this study. These are based on Georgia’s Integrated Living Conditions Survey 2022 (GEOSTAT, 2023). We take this oportunity to standardize the household identification variable to household_id.\n\n# Household size (includes no. of family members and weights)\nhh_size &lt;- read_sav(\n  \"data/ilcs_2023/familysize.sav\") %&gt;% \n  rename(household_id = UID)\n\n# Processed income at household level\nhh_income &lt;- read_sav(\n  \"data/ilcs_2023/tblincomes.sav\") %&gt;% \n  rename(household_id = UID)\n\n# Consumption aggregate at household level \nhh_expenditure &lt;- read_sav(\n  \"data/ilcs_2023/tblexpenditures.sav\") %&gt;% \n  rename(household_id = UID,\n         # rename total expenditure variables\n         total_expenditure = MTlianixarjebi_,\n         total_expenditure_aeq06 = MTlianimoxmareba_EqAdScale,\n         total_expenditure_aeq08 = Mtlianimoxmareba_EqAdScale_08)\n\n# Characteristics of the dwelling\nhh_chars &lt;- read_sav(\n  \"data/ilcs_2023/tblshinda01.sav\") %&gt;% \n  rename(household_id = UID)\n\n# Household location\nhh_location &lt;- read_sav(\n  \"data/ilcs_2023/sysschedule.sav\") %&gt;% \n  rename(household_id = UID)\n\n# Persons (pp)\npp &lt;- read_sav(\n  \"data/ilcs_2023/tblshinda02.sav\") %&gt;% \n  rename(household_id = UID)\n\n# Food diary\nfood_q &lt;- read_sav(\n  \"data/ilcs_2023/tblconsumption.sav\") %&gt;% \n  rename(household_id = UID)\n\nfood_price &lt;- read_sav( \n  \"data/ilcs_2023/tblavgprices.sav\")\n\nWe also have Continuous Labor Survey data at the individual level, which will come in handy if we do not get access to the labor part of the ILCS. See data folder for documents describing the datasets.\n\n# Labor Force Survey\nlfs_2023 &lt;- read_sav(\n  \"data/lfs_2023/LFS_ECSTAT_ENG_2023.sav\") %&gt;% \n  rename(household_id = UID)\n\n# Labor Force Survey Demographic Characteristics\nlfs_2023_dem &lt;- read_sav(\n  \"data/lfs_2023/LFS_Demographic_ENG_2023.sav\") %&gt;% \n  rename(household_id = UID)\n\nWe will work non-destructively, meaning we will not rewrite these data sets and we will only create intermediate data frame objects from them to perform transformations, selections and other data management tasks. For example, we will keep household assignment to poverty status and consumption deciles handy by creating a subset of our hh_expenditure data with only our household identifiers, deciles, and poverty if available.\n\n# We will estimate deciles from consumption\ndeciles &lt;- hh_expenditure %&gt;% \n  select( \n    # Keep household id and expenditure variables\n    household_id, \n    total_expenditure,\n    total_expenditure_aeq06, # Adult equivalent * 0.6\n    total_expenditure_aeq08) # Adult equivalent * 0.8\n\nOur population data comes from UN’s projections.\n\npopulation_projections &lt;- read_dta(\"data/population/UN2022_population.dta\") %&gt;% \n  filter(country == iso) # we filter for Georgia\n\nThe macro scenario dataset is an input provided by the Macroeconomic CGE simulation team, with yearly information on GDP, working age population, employment by economic activity (for an aggregation of three sectors: agriculture, manufacturing, and services), wages by economic activity, value added by economic activity, remittances, consumer price index, food price index and energy price index (for a bundle of gas, oil, coal, electricity) by decile (10 representative households in the macro model), and carbon tax revenue transfers to household deciles.\n\nscenario_file &lt;- \"data/ARM-Microsimulation/GEO_MacroScenarioInformation.xlsx\"\n# scenario_varlist &lt;- read_xlsx(\n#   \"data/ARM-Microsimulation/ARM_Macro_varlist.xlsx\")\n# prices_2030 &lt;- \n#   read.csv(\"data/ARM-Microsimulation/prices2030.csv\")\n\nEconomic Activities in the Survey is in Georgian. The following dataset is a lookup table with the English names.\n\n# Pending\nsectors &lt;- read_xlsx(\"data/ARM-HH-survey/economic_activity_codes.xlsx\")\n\nWe also have geographical information for level 1 in Shapefile format, which we import with the sf package. We rename the column with the name of the administrative region to match our household survey data set conventions to ease mergers. The dplyr package from the tidyverse meta package allows us to “pipe” or link processing steps using the %&gt;% pipe. Although there is no geoprocessing in this analysis, this will come in handy for graphical presentations.\n\n# Georgia administrative level 1 shapefile\nadm1 &lt;- sf::read_sf(\"data/gis/geo-adm1.shp\") |&gt; \n  dplyr::select(ADM1_PCODE, ADM1_EN, ADM1_KA, geometry) |&gt; \n  dplyr::arrange(ADM1_PCODE)\n\nAnd we plot it for reference (see Figure 2). This is done with the tmap R package and the code shown below.\n\ntmap::tm_shape(adm1)+\n  tmap::tm_fill(\"ADM1_EN\", legend.show = FALSE, palette = \"Set1\") +\n  tmap::tm_text(\"ADM1_EN\", size = 0.65, auto.placement = T, col = \"black\")+\n  tmap::tm_layout(frame = F)\n\n\n\n\n\n\n\nFigure 2: Map of Georgia at administrative level 1 (ADM1)",
    "crumbs": [
      "Home",
      "Supporting materials",
      "Georgia CCDR Microsimulation"
    ]
  },
  {
    "objectID": "supporting-materials/geo-microsimulation.html#data-preparation-income-outliers-and-missings",
    "href": "supporting-materials/geo-microsimulation.html#data-preparation-income-outliers-and-missings",
    "title": "Georgia CCDR Microsimulation",
    "section": "4 Data preparation income outliers and missings",
    "text": "4 Data preparation income outliers and missings\nWe start with various renames for standardization. Naming conventions in the guidance code use traditional abbreviations like nli for non-lablor income. We are opting for more descriptive variable names like non_labor_income, labor_income, etc. to have more easily readable code. We make an exception for total consumption (tc), because it’s a variable that we use in every scenario and it supersedes lenght limits when adding scenario identifiers.\n\n# Uncomment the correct total expenditure variable below\nex &lt;- hh_expenditure %&gt;% \n  rename(\n    tc =\n      total_expenditure\n      #total_expenditure_aeq06 # Adult equivalent * 0.6\n      #total_expenditure_aeq08 # Adult equivalent * 0.8\n      )\n\n\n4.1 Demographic characteristics, education, labor force\nHere the original code calls for Zone data, which is not present in our dataset, due to the different administrative structure of Georgia. However, we use hh_01_code (settlement) for this purpose. In the end, this variable was never used.\nDemographic data, merge with zone data Note that ed_03 (educy) below is not years of education, but education level (primary, general, secondary, etc.) However, it is ordered in a way that higher levels imply more years of education. We perform several steps within the first pipe call. The variable lstatus (Labor Force Status) here is very important for the reweigthing of the dataset later on. Note that from here onwards we will be creating _microsim versions of our datasets with the transformations needed for calculations. That way we avoid changing our original data and can refer to it later without fearing we’ve left things behind.\n\npp_microsim &lt;- pp %&gt;%\n  mutate(\n    # Demographic characteristics\n    # Unique person id\n    person_id = paste0(household_id, \"-\", str_pad(MemberNo, 2, pad = \"0\")),\n    head = ifelse(Relations == 1, 1, 0),\n    # Education level\n    educy = ifelse(is.na(Education), 0, Education),\n    # Labor Force Status\n    lstatus = case_when(\n      # 1. Employed\n      est_03 == 1 | est_04 == 1 | est_05 == 1 |\n        est_06 == 1 | est_08 == 1 ~ 1L,\n      # 2. Unemployed (available, and searching)\n      est_10 == 1 ~ 2L,\n      # 3. Inactive (available, not searching)\n      est_10 == 2 ~ 3L,\n      # Out of the labor force\n      .default = 4L # Default to OLF\n    ),\n    employed = (lstatus == 1),\n    # Salaried status (1. paid employee; 2 self-employed)\n    salaried = ifelse(\n      !is.na(emp_11a),\n      1L,\n      ifelse(is.na(emp_11a) &\n               employed == TRUE, 0L, NA_integer_)\n    )\n  ) %&gt;%\n  rename(rel = mem_03, # relationship to HH head\n         gender = mem_02,\n         age = mem_05)\n\nLater, when we conduct the reweighting of the dataset, we need to summarize into three levels of education.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(calif = case_when(\n    educy &gt;= 0 & educy &lt;= 4 ~ \"None - General\",\n    educy &gt; 3 & educy &lt;= 9 ~ \"Secondary - Vocational\",\n    educy &gt; 7 & educy &lt;= 13 ~ \"Higher +\",\n    TRUE ~ NA_character_  # Values outside the specified ranges\n  ))\n\nCount the number of employed persons by household. Note that it is necessary to explicitly tell R to ignore missing values(NA). This is different from Stata where 1 + .= 1 (where . is “missing”). In R 1 + NA = NA (where NA means “not available”). Not adding na.rm = TRUE to aggregation functions such as sum() in Listing 1 below will not throw an error and only provide a column with NA for households where at least one individidual has an employed status of NA.\n\n\n\n\nListing 1: Employed in household\n\n\n# Pending data from pp_ecstat\nhh_labor &lt;- pp_ecstat %&gt;% \n  mutate(employed = (Status == 1)) %&gt;% \n  group_by(household_id) %&gt;% \n  # Count within each household\n  mutate(employed_hh = sum(employed, na.rm = TRUE)) %&gt;%   \n  ungroup() \n\n\n\n\nHere the original Stata code calculates income variables and aggregates them by household. We skip that because the dataset ic already has these elements calculated by the WB poverty team. We’ll add them later as we need them.\nHowever, as we’ll see later labor income information is heavily non-reported in the dataset. Labor income is a crucial step in merging the dataset with macroeconomic information and so we will predict income for those that do not report it below. These variables are related to labor income, amount and frequency, which we have to standardized to a monthly or yearly value.\nPrimary and Secondary Job income:\n\nemp_11 How much was %rostertitle%’s payment for wages/salary/income for last month?\nemp_12 What period of time was the wage/income for?\nemp_25 How much was %rostertitle%’s payment for wages/salary/income for last month?\nemp_26 What period of time was the wage/income for?\n\nBonus, In-Kind, and food from job was not asked in Georgia, If it were, you should add a mutate() statement like the ones below for each subcategory in Listing 2. We use coalesce(colname, 0) when adding the annual_labor_total again to prevent sums of NA’s. This function replaces a value with 0 within the calculation if it’s missing, but doesn’t change its value permanently.\n\n\n\n\nListing 2: Annualized labor income\n\n\npp_microsim &lt;- pp_microsim %&gt;% \n  # Labor income primary job\n  mutate(annual_labor_income_primary = case_when(\n    emp_12 == 1 ~ emp_11 * 365,\n    emp_12 == 2 ~ (emp_11/7) * 365,  # Assuming weekly rate \n    emp_12 == 3 ~ (emp_11/14) * 365,\n    emp_12 == 4 ~ emp_11 * 12,\n    emp_12 == 5 ~ emp_11 * 2,\n    emp_12 == 6 ~ emp_11,\n    emp_12 == 7 ~ NA\n  ))   %&gt;% \n  # Labor income secondary job\n  mutate(annual_labor_income_secondary = case_when(\n    emp_26 == 1 ~ emp_25 * 365,\n    emp_26 == 2 ~ (emp_25/7) * 365,  # Assuming weekly rate \n    emp_26 == 3 ~ (emp_25/14) * 365,\n    emp_26 == 4 ~ emp_25 * 12,\n    emp_26 == 5 ~ emp_25 * 2,\n    emp_26 == 6 ~ emp_25,\n    emp_26 == 7 ~ NA\n  )) %&gt;% \n  # Annual labor total in thousands of dram\n  mutate(annual_labor_total = \n           (coalesce(annual_labor_income_primary, 0) + \n           coalesce(annual_labor_income_secondary, 0))/1000)\n\n# Restore annual_labor_total to NA if both NA\npp_microsim &lt;- pp_microsim %&gt;% \n  mutate(annual_labor_total =\n           if_else(\n             is.na(annual_labor_income_primary)\n             & is.na(annual_labor_income_secondary),\n         NA, \n         annual_labor_total))\n\n\n\n\nNow we need to check the share of individuals that are employed, but did not report income. This is done in Listing 3 below.\n\n\n\n\nListing 3: Employed with no income reported\n\n\ntotal_employed_no_income &lt;- pp_microsim %&gt;%\n  filter(employed == TRUE & is.na(annual_labor_total)) %&gt;% \n  nrow()\n\ntotal_employed &lt;- pp_microsim %&gt;%\n  filter(employed == TRUE) %&gt;%\n  nrow()\n\npercent_employed_no_income &lt;- \n  (total_employed_no_income / total_employed) * 100\n\nprint(\n  paste0(\n    \"There is \",\n    format(\n      percent_employed_no_income,digits = 2, nsmall=2\n      ),\n    \"% of the employed population that reports no income.\")\n  )\n\n\n\n\nWe also need to mark income outliers as those with incomes outside 5 standard deviations.\n\npp_microsim &lt;- pp_microsim  %&gt;% \n  mutate(\n    # Calculate standard deviation\n    sd = sd(annual_labor_total, na.rm = TRUE), \n    d = annual_labor_total / sd,                \n    # Combined outlier condition\n    outlier = (d &gt; 5) | (employed == TRUE & annual_labor_total == 0), \n    # Mark potential missings\n    missings = if_else(employed == TRUE, is.na(annual_labor_total), NA) \n  ) \n\nEconomic sector. The economic sectors dataset contains a lookup table for sector aggregation which we add to the pp_microsim database in Listing 4.\n\n\n\n\nListing 4: Sector aggregation\n\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(emp_04 = as.integer(emp_04)) %&gt;% \n  left_join(sectors, join_by(\"emp_04\" == \"economic_activity_code\") ) %&gt;% \n  rename(sector = ea_shortcode)\n\n\n\n\nSome individuals report no sector for either their primary or secondary job. In Listing 5 we find out the sector of other family members in their home and assign the sector of whoever is closest using fill( other_sector, .direction = \"downup\").\n\n\n\n\nListing 5: Assign sector to those who don’t report one\n\n\npp_microsim &lt;- pp_microsim %&gt;%\n  group_by(household_id) %&gt;%\n  mutate(\n    # Create a temporary variable 'other_sector'\n    # which captures the sector of any employed \n    # individual in the household\n    other_sector = \n      if_else(employed == TRUE & !is.na(sector), sector, NA_real_)\n  ) %&gt;%\n  # Use 'fill' to propagate 'other_sector' values within the household\n  fill(other_sector, .direction = \"downup\") %&gt;%\n  mutate(\n    # Impute missing 'sector' values based on the 'other_sector'\n    sector = \n      if_else(is.na(sector) & employed == TRUE, other_sector, sector)\n  ) %&gt;%\n  # Drop the temporary 'other_sector' variable\n  select(-other_sector) %&gt;%\n  ungroup()\n\n\n\n\nWe then assign a specific value for missing sectors for those employed with no one else in the hh to assign value. We select services as it’s the heaviest sector in the dataset (we do it like this, instead of say, any matching technique, because it’s only 2 observations).\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(sector = if_else(is.na(sector) & employed == TRUE, 3, sector))\n\nWe provide value labels for sector factors.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(sector_name = factor(sector, levels = c(1, 2, 3),\n                         labels = c(\"Agriculture\", \n                                    \"Manufacturing\", \n                                    \"Services\")))\n\nWe make sure that those outside the labor force (OLF) do not report a sector, which we replace with NA for those who meet the condition.\n\n\n\n\nListing 6: No sector for OLF\n\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(lstatus = as.numeric(lstatus),\n         sector = \n           if_else(lstatus == 4, \n                   as.character(NA), \n                   as.character(sector)),\n         industry = as.factor(sector)) %&gt;%\n  # We need this for reweighting and \n  # not messing up the regression below.\n  mutate(sector_w = sector)\n\n\n\n\n\n\n4.2 The regression\nSince labor income was a key variable, which we needed to match with the future wage bill by economic activity, we first checked for missing values among employed individuals. We found that almost a third of respondents (28.6%) did not report income for either their primary or secondary job. To overcome this limitation, we used the available information from the remaining respondents to estimate an extended Mincer equation, as shown in Equation 1, and implemented in Listing 7. For the respondents with available information, we also identified outliers as those outside of five standard deviations from the mean labor income.\n\\[\n\\ln(lab_i) = \\beta_0 + \\beta_1 \\text{age}_i + \\\\\n\\beta_2 \\text{gender}_i + \\beta_3 \\text{educy}_i + \\\\\n\\beta_4 \\text{age}^2_i + \\beta_5 \\text{marz}_i + \\\\\n\\beta_6 \\text{sector}_i + \\epsilon_i\n\\tag{1}\\]\nWhere:\n\n\\(\\ln(lab_i)\\) is the natural logarithm of labor income for individual \\(i\\).\n\\(\\beta_0\\) is the intercept term.\n\\(\\beta_1, \\beta_2, \\beta_3, \\beta_4, \\beta_5, \\beta_6\\) are the coefficients for the respective independent variables.\n\\(\\text{age}_i\\) is the age of individual \\(i\\).\n\\(\\text{gender}_i\\) is a binary variable indicating the gender of individual \\(i\\) (1 for male, 2 for female).\n\\(\\text{educy}_i\\) represents the level of education for individual \\(i\\) (ordered: 1) None to General, 2) Secondary to Vocational, 3) Higher education).\n\\(\\text{age}^2_i\\) is the square of the age of individual \\(i\\), included to capture non-linear effects of age on labor income.\n\\(\\text{marz}_i\\) represents the region where individual \\(i\\) resides.\n\\(\\text{sector}_i\\) represents the sector of employment for individual \\(i\\) (i.e., agriculture, manufacturing or services).\n\\(\\epsilon_i\\) is the error term for individual \\(i\\).\n\nWe first prepare our variables for the regression.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(\n    educy2 = educy^2,\n    age2 = age^2,\n    male = case_when(\n      gender == 1 ~ 1,\n      gender == 2 ~ 0\n    ),\n    lnlab = log(annual_labor_total),\n    simuli = NA_real_ # Initialize simuli\n  )\n\nFilter the data for regression conditions.\n\nregression_data &lt;- pp_microsim %&gt;%\n  filter(employed == TRUE & outlier == FALSE & missings == FALSE)\n\nRegression model.\n\n\n\n\nListing 7: Income regression model\n\n\nmodel &lt;- lm(lnlab ~ age + gender + educy + age2 + marz + sector, \n            data = regression_data)\n\n\n\n\nPredict for specific conditions\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(\n    condition = (lstatus == 1 & (outlier == TRUE | missings == TRUE))\n  )\n\nApplying predictions.\nNote: The ‘predict’ function in R does not directly support conditions within the function call, so we handle this by filtering or subsetting the data as needed.\ntemp2 equivalent - Note: ‘type = “response”’ might be needed depending on model type.\n\npp_microsim$simuli[pp_microsim$condition==TRUE] &lt;- exp(\n  predict(model, pp_microsim[pp_microsim$condition==TRUE, ], type = \"response\"))\n\nHandling negative values in ‘simuli’.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(\n    simuli = if_else(simuli &lt; 0, 0, simuli)\n  )\n\nThere were 8 observations that met the criteria:\nWe will replace annual_labor_total with this value for those observations.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(annual_labor_total = if_else(\n    employed == TRUE & (outlier == TRUE | missings == TRUE),\n    simuli, annual_labor_total))\n\n# And get monthly incomes for everyone\npp_microsim &lt;- pp_microsim %&gt;% \n  mutate(monthly_labor_income = annual_labor_total / 12)\n\nMerging datasets.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  left_join(poverty_designations, by = \"household_id\")\n\n\n\n4.3 Total income and shares\nTotal labor income at HH level.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  group_by(household_id) %&gt;%\n  mutate(lab_hh = sum(annual_labor_total, na.rm = TRUE)) %&gt;%\n  ungroup()\n\nMonthly incomes come from the ic data set.\n\nincomes &lt;- ic %&gt;% \n  select(household_id, inc1, inc2, inc3, inc4, inc5, inc6, inc7, inc8)\n\nTotal income at HH level (the commented out portion was a less efficient way of accomplishing the same result of coalescing NAs to 0 so that the sum can be performed). Note that here we need to use the magittr pipe %&gt;% instead of the newer Native Pipe %&gt;% , because we need to reference the correct scope with the dot ..\n\npp_microsim &lt;- pp_microsim %&gt;%\n  left_join(incomes, by = c(\"household_id\" = \"household_id\")) %&gt;%\n  mutate(across(inc5:inc8, ~replace_na(., 0))) %&gt;%\n  mutate(nli_hh = 12 * rowSums(select(., inc5:inc8), na.rm = TRUE)) %&gt;%\n  mutate(income_hh = lab_hh + nli_hh)\n\n# pp_microsim &lt;- pp_microsim %&gt;%\n#   left_join(incomes, join_by(household_id == household_id)) %&gt;% \n#   mutate(nli_hh = (  coalesce(inc5) + \n#                      coalesce(inc6) +\n#                      coalesce(inc7) +\n#                      coalesce(inc8)) * 12) %&gt;% \n#   mutate(income_hh = lab_hh + nli_hh)\n\nFinal subset of data.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  select(household_id, person_id, industry, salaried,\n         rural_dummy, hhsize,hhsize_R, marz_no, aepc, weight, \n         Foodpovln2022, Lpovln2022, Upovln2022, Avpovln2022, \n         poor_Foodpovln2022, poor_Lpovln2022, poor_Upovln2022, \n         poor_Avpovln2022, decile, settlement, urban_rural,\n         gender, age, head, rel, educy, calif, sector, sector_name,\n         annual_labor_total,annual_labor_income_primary,\n         annual_labor_income_secondary,monthly_labor_income,\n         lstatus, sector_w, marz.x ) %&gt;%\n  rename(marz = marz.x)\n\n# Exporting to Stata (might be necessary for reweigthing with wentropy)\n# write_dta(pp_microsim, path = \"outputs/pp_microsim.dta\", version = 10)",
    "crumbs": [
      "Home",
      "Supporting materials",
      "Georgia CCDR Microsimulation"
    ]
  },
  {
    "objectID": "supporting-materials/geo-microsimulation.html#un-population-projections",
    "href": "supporting-materials/geo-microsimulation.html#un-population-projections",
    "title": "Georgia CCDR Microsimulation",
    "section": "5 UN Population Projections",
    "text": "5 UN Population Projections\nNow we are ready to move to our demographic projections and macroeconomic model information.\nFirst, filtering based on country (our iso variable).\n\npopulation_projections &lt;- population_projections  %&gt;%  \n  filter(country == iso)\n\nCollapsing data by summing up variables starting with “yf” and “ym” and reshaping data to long format.\n\npopulation_projections &lt;- population_projections %&gt;%\n  group_by(Variant, country, cohort) %&gt;%\n  summarize(across(starts_with(c(\"yf\", \"ym\")), sum)) %&gt;%\n  ungroup()\n\npopulation_projections &lt;- pivot_longer(population_projections,\n                              cols = starts_with(c(\"yf\", \"ym\")),\n                              names_to = c(\".value\", \"year\"),\n                              names_pattern = \"(yf|ym)(.*)\")\n\nCreating new variable total_population as the sum of yf and ym. Dropping country variables.\n\npopulation_projections &lt;- population_projections %&gt;%\n  mutate(total_population = yf + ym) %&gt;%\n  select( -country) %&gt;% \n  mutate(year = as.numeric(year))\n\nSummarizing the year to find the range.\n\nminyear &lt;- survey_year # Make sure `survey_year` is correctly defined\nmaxyear &lt;- max(as.numeric(population_projections$year))\n\nWe have that the “Min Year” is minyear and the “Max Year” is maxyear. Now we create a population growth rate by demographic variant dataset. We initialize an empty list to store our data by variant and we loop over variants to create this list.\n\n# With minyear and maxyear defined above\n# Initialize a list to store growth data\npop_growth &lt;- list()\n\n# Loop over variants\nvariants &lt;- unique(population_projections$Variant)\nfor (variant in variants) {\n  for (t in minyear:maxyear) {\n    \n    # Calculate population for year t\n    pop_t &lt;- population_projections %&gt;%\n      filter(year == t, Variant == variant) %&gt;%\n      summarize(sum_pop = sum(total_population)) %&gt;%\n      pull(sum_pop)\n    \n    # Calculate population for base year\n    pop_base &lt;- population_projections %&gt;%\n      filter(year == minyear, Variant == variant) %&gt;%\n      summarize(sum_pop = sum(total_population)) %&gt;%\n      pull(sum_pop)\n    \n    # Calculate growth rate and store in list with dynamic naming\n    growth_rate &lt;- pop_t / pop_base\n    pop_growth[[paste0(t, \"_\", variant)]] &lt;- list(\n      growth_rate = growth_rate, pop_t = pop_t\n      )\n  }\n}\n\nWith the list ready, we convert back to dataframe by stitching the list elements one on top of the other.\n\n# Convert list to dataframe\npop_growth &lt;- do.call(rbind, lapply(names(pop_growth), function(x) {\n  # Extract year and variant from the name\n  parts &lt;- unlist(strsplit(x, \"_\"))\n  year &lt;- as.integer(parts[1])\n  variant &lt;- parts[2]\n  \n  # Create a tibble for each entry\n  tibble(year = year, \n         variant = variant, \n         total_population = pop_growth[[x]]$pop_t,\n         pop_growth_rate = pop_growth[[x]]$growth_rate)\n}))\n\n# Arrange the dataframe for better readability\npop_growth &lt;- arrange(pop_growth, variant, year)\n\n# Display the first few rows of the dataframe\npop_growth[c(1:09),]",
    "crumbs": [
      "Home",
      "Supporting materials",
      "Georgia CCDR Microsimulation"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This site was created for reproducibility purposes by World Bank consultant Renato Vargas.\nContact information:\n\nE-mail: hvargasaldana [at] worldbank [dot] org\nLinkedIn: https://www.linkedin.com/in/revargas/\nWebsite: renatovargas.com"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Georgia Country Climate and Development Report",
    "section": "",
    "text": "This website contains background documents and guides created for Georgia’s World Bank Country Climate and Development Report. Authorship is indicated in each document.\n\n\n\n\n\n\n\n\nFigure 1: Map of Georgia at administrative level 1 (ADM1)"
  }
]