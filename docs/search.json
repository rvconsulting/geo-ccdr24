[
  {
    "objectID": "supporting-materials/sam-shares-data-request.html",
    "href": "supporting-materials/sam-shares-data-request.html",
    "title": "SAM Shares Data Request",
    "section": "",
    "text": "In this data request, we estimate shares to disaggregate the Social Accounting Matrix for the Macroeconomic team.\n\n\n\nHH split: Split our representative household into income quintiles and rural/urban households.\nLabor split: Split labor into 6 types according to gender and skill level.\nEconomic activity split: Split wages and capital by economic activities.\nSplit household consumption by urban/rural, quintiles and economic activity.\n\n\n\n\n\n# Clean workspace\nrm(list = ls())\n\n# Georgia country ISO code\niso &lt;- \"GEO\"\n\n# Survey year\nsurvey_year &lt;- 2023\n\n# Exchange rate USD per GEL\ner &lt;- 0.37\n\n# Years of interest for our macroeconomic scenario analysis\n# analysis_years &lt;- c(2030, 2050)\n\nWe will use the following libraries for this exercise.\n\nlibrary(tidyverse)\nlibrary(haven)\nlibrary(readxl)\nlibrary(openxlsx)\nlibrary(gt)\n\n\n\n\nWe use data from the 2023 survey for the Labor Split and data from the 2022 survey for the household expenditure and capital shares in In mil. GEL per year per household type.\n\n #| lst-label: original-datasets\n\n# Household Unique ID, Weights, Location and other basic variables\nhh_basics &lt;- read_sav(\n  \"data/ilcs_2023/sysschedule.sav\") |&gt;\n  mutate(\n    UID = as.integer(UID))\n\n# Household size (includes no. of family members)\nhh_size &lt;- read_sav(\n  \"data/ilcs_2023/familysize.sav\")|&gt; \n  mutate(\n    UID = as.integer(UID))\n\n# Processed income at household level\nhh_income &lt;- read_sav(\n  \"data/ilcs_2023/tblincomes.sav\")|&gt; \n  mutate(\n    UID = as.integer(UID))\n\n# Consumption aggregate at household level \nhh_expenditure &lt;- read_sav(\n  \"data/ilcs_2023/tblexpenditures.sav\")|&gt; \n  rename(# rename total expenditure variables\n         total_expenditure = MTlianixarjebi_,\n         total_expenditure_aeq06 = MTlianimoxmareba_EqAdScale,\n         total_expenditure_aeq08 = Mtlianimoxmareba_EqAdScale_08) |&gt; \n  mutate(\n    UID = as.integer(UID))\n\n# Characteristics of the dwelling\nhh_chars &lt;- read_sav(\n  \"data/ilcs_2023/tblshinda01.sav\")|&gt;\n  mutate(\n    UID = as.integer(UID))\n\n# Persons (pp)\npp &lt;- read_sav(\n  \"data/ilcs_2023/tblshinda02.sav\") |&gt; \n  mutate(\n    UID = as.integer(UID),\n    MemberNo = as.integer(MemberNo))\n\n# Labor (pp)\npp_labor &lt;- read_sav(\n  \"data/ilcs_2023/tblshinda05_1.sav\") |&gt; \n  mutate(\n    UID = as.integer(UID),\n    MemberNo = as.integer(MemberNo),\n    Q5  = as.integer(Q5),\n    Q12 = as.integer(Q12)) \n\n# Poverty\npoverty &lt;- read_dta(\n  \"data/ilcs_2023/POVERTY_stata.dta\") |&gt; \n  mutate(\n    UID = as.integer(UID))\n\n# Ind. Poverty\nind_poverty &lt;- read_dta(\n  \"data/ilcs_2023/IND_POVERTY_stata.dta\") |&gt; \n  rename(MemberNo = memberno) |&gt; \n  mutate(\n    UID = as.integer(UID),\n    MemberNo = as.integer(MemberNo))\n\nWe also need look-up tables.\n\nsam_activities &lt;- read_excel(\n    \"data/sam/classifications.xlsx\",\n    sheet = \"SAM-REV2\",\n    col_names = T,\n    col_types = \"text\",\n  )\n\nsam_factors &lt;- read_excel(\n    \"data/sam/classifications.xlsx\",\n    sheet = \"SAM factors\",\n    col_names = T,\n    col_types = \"text\",\n  )\n\ncoicop &lt;- read_excel(\n    \"data/sam/classifications.xlsx\",\n    sheet = \"COICOP\",\n    col_names = T,\n    col_types = \"text\",\n  ) |&gt; \n  mutate(simple_code = as.integer(gsub(\"\\\\.\", \"\", Coicop)))\n\ncoicop_filtered &lt;- coicop |&gt; \n  filter( nchar(as.character(simple_code)) &gt;= 5)\n\n\n\n\nFirst we check that our dataset amounts to population totals.\n\nweights &lt;- hh_basics |&gt; \n  select(UID, QuartNo, Weights)\n\nhh_size |&gt; \n  left_join(weights, join_by(UID)) |&gt; \n#  filter(QuartNo == 110) |&gt; \n  summarize(\n    \"Population\" = sum(FamilySize * Weights, na.rm = T),\n    \"Households\" = sum(Weights, na.rm = T)) |&gt; \n  gt()\n\n\n\n\n\n\n\nPopulation\nHouseholds\n\n\n\n\n14861930\n4499690\n\n\n\n\n\n\n\nUpon first exploration, we see that the population amounts to 14,861,930 individuals, living in 4,499,690 households, when in reality we have a total population estimate of 3,702,130 individuals, living in 1,109,130 households. This is because the survey covers four quarters and households are interviewed four times in the year. So we need to drop households for our estimates and keep only those related to one quarter. Since we need information for 2022, but our dataset is for 2023, we will use the first quarter (Q1), which is closer to the required year.\n\npop_by_quarter &lt;- hh_size |&gt; \n  left_join(weights, join_by(UID)) |&gt; \n  group_by(QuartNo) |&gt; \n  summarize(\n    \"Population\" = sum(FamilySize * Weights, na.rm = T),\n    \"Households\" = sum(Weights, na.rm = T))\n\npop_by_quarter |&gt; \n  gt()\n\n\n\n\n\n\n\nQuarter ID\nPopulation\nHouseholds\n\n\n\n\n107\n3713876\n1122110\n\n\n108\n3654991\n1114584\n\n\n109\n3729558\n1130628\n\n\n110\n3763505\n1132368",
    "crumbs": [
      "Home",
      "Supporting materials",
      "SAM Shares Data Request"
    ]
  },
  {
    "objectID": "supporting-materials/sam-shares-data-request.html#objectives",
    "href": "supporting-materials/sam-shares-data-request.html#objectives",
    "title": "SAM Shares Data Request",
    "section": "",
    "text": "HH split: Split our representative household into income quintiles and rural/urban households.\nLabor split: Split labor into 6 types according to gender and skill level.\nEconomic activity split: Split wages and capital by economic activities.\nSplit household consumption by urban/rural, quintiles and economic activity.",
    "crumbs": [
      "Home",
      "Supporting materials",
      "SAM Shares Data Request"
    ]
  },
  {
    "objectID": "supporting-materials/sam-shares-data-request.html#preliminaries",
    "href": "supporting-materials/sam-shares-data-request.html#preliminaries",
    "title": "SAM Shares Data Request",
    "section": "",
    "text": "# Clean workspace\nrm(list = ls())\n\n# Georgia country ISO code\niso &lt;- \"GEO\"\n\n# Survey year\nsurvey_year &lt;- 2023\n\n# Exchange rate USD per GEL\ner &lt;- 0.37\n\n# Years of interest for our macroeconomic scenario analysis\n# analysis_years &lt;- c(2030, 2050)\n\nWe will use the following libraries for this exercise.\n\nlibrary(tidyverse)\nlibrary(haven)\nlibrary(readxl)\nlibrary(openxlsx)\nlibrary(gt)",
    "crumbs": [
      "Home",
      "Supporting materials",
      "SAM Shares Data Request"
    ]
  },
  {
    "objectID": "supporting-materials/sam-shares-data-request.html#datasets-and-correspondence-tables",
    "href": "supporting-materials/sam-shares-data-request.html#datasets-and-correspondence-tables",
    "title": "SAM Shares Data Request",
    "section": "",
    "text": "We use data from the 2023 survey for the Labor Split and data from the 2022 survey for the household expenditure and capital shares in In mil. GEL per year per household type.\n\n #| lst-label: original-datasets\n\n# Household Unique ID, Weights, Location and other basic variables\nhh_basics &lt;- read_sav(\n  \"data/ilcs_2023/sysschedule.sav\") |&gt;\n  mutate(\n    UID = as.integer(UID))\n\n# Household size (includes no. of family members)\nhh_size &lt;- read_sav(\n  \"data/ilcs_2023/familysize.sav\")|&gt; \n  mutate(\n    UID = as.integer(UID))\n\n# Processed income at household level\nhh_income &lt;- read_sav(\n  \"data/ilcs_2023/tblincomes.sav\")|&gt; \n  mutate(\n    UID = as.integer(UID))\n\n# Consumption aggregate at household level \nhh_expenditure &lt;- read_sav(\n  \"data/ilcs_2023/tblexpenditures.sav\")|&gt; \n  rename(# rename total expenditure variables\n         total_expenditure = MTlianixarjebi_,\n         total_expenditure_aeq06 = MTlianimoxmareba_EqAdScale,\n         total_expenditure_aeq08 = Mtlianimoxmareba_EqAdScale_08) |&gt; \n  mutate(\n    UID = as.integer(UID))\n\n# Characteristics of the dwelling\nhh_chars &lt;- read_sav(\n  \"data/ilcs_2023/tblshinda01.sav\")|&gt;\n  mutate(\n    UID = as.integer(UID))\n\n# Persons (pp)\npp &lt;- read_sav(\n  \"data/ilcs_2023/tblshinda02.sav\") |&gt; \n  mutate(\n    UID = as.integer(UID),\n    MemberNo = as.integer(MemberNo))\n\n# Labor (pp)\npp_labor &lt;- read_sav(\n  \"data/ilcs_2023/tblshinda05_1.sav\") |&gt; \n  mutate(\n    UID = as.integer(UID),\n    MemberNo = as.integer(MemberNo),\n    Q5  = as.integer(Q5),\n    Q12 = as.integer(Q12)) \n\n# Poverty\npoverty &lt;- read_dta(\n  \"data/ilcs_2023/POVERTY_stata.dta\") |&gt; \n  mutate(\n    UID = as.integer(UID))\n\n# Ind. Poverty\nind_poverty &lt;- read_dta(\n  \"data/ilcs_2023/IND_POVERTY_stata.dta\") |&gt; \n  rename(MemberNo = memberno) |&gt; \n  mutate(\n    UID = as.integer(UID),\n    MemberNo = as.integer(MemberNo))\n\nWe also need look-up tables.\n\nsam_activities &lt;- read_excel(\n    \"data/sam/classifications.xlsx\",\n    sheet = \"SAM-REV2\",\n    col_names = T,\n    col_types = \"text\",\n  )\n\nsam_factors &lt;- read_excel(\n    \"data/sam/classifications.xlsx\",\n    sheet = \"SAM factors\",\n    col_names = T,\n    col_types = \"text\",\n  )\n\ncoicop &lt;- read_excel(\n    \"data/sam/classifications.xlsx\",\n    sheet = \"COICOP\",\n    col_names = T,\n    col_types = \"text\",\n  ) |&gt; \n  mutate(simple_code = as.integer(gsub(\"\\\\.\", \"\", Coicop)))\n\ncoicop_filtered &lt;- coicop |&gt; \n  filter( nchar(as.character(simple_code)) &gt;= 5)",
    "crumbs": [
      "Home",
      "Supporting materials",
      "SAM Shares Data Request"
    ]
  },
  {
    "objectID": "supporting-materials/sam-shares-data-request.html#population-totals",
    "href": "supporting-materials/sam-shares-data-request.html#population-totals",
    "title": "SAM Shares Data Request",
    "section": "",
    "text": "First we check that our dataset amounts to population totals.\n\nweights &lt;- hh_basics |&gt; \n  select(UID, QuartNo, Weights)\n\nhh_size |&gt; \n  left_join(weights, join_by(UID)) |&gt; \n#  filter(QuartNo == 110) |&gt; \n  summarize(\n    \"Population\" = sum(FamilySize * Weights, na.rm = T),\n    \"Households\" = sum(Weights, na.rm = T)) |&gt; \n  gt()\n\n\n\n\n\n\n\nPopulation\nHouseholds\n\n\n\n\n14861930\n4499690\n\n\n\n\n\n\n\nUpon first exploration, we see that the population amounts to 14,861,930 individuals, living in 4,499,690 households, when in reality we have a total population estimate of 3,702,130 individuals, living in 1,109,130 households. This is because the survey covers four quarters and households are interviewed four times in the year. So we need to drop households for our estimates and keep only those related to one quarter. Since we need information for 2022, but our dataset is for 2023, we will use the first quarter (Q1), which is closer to the required year.\n\npop_by_quarter &lt;- hh_size |&gt; \n  left_join(weights, join_by(UID)) |&gt; \n  group_by(QuartNo) |&gt; \n  summarize(\n    \"Population\" = sum(FamilySize * Weights, na.rm = T),\n    \"Households\" = sum(Weights, na.rm = T))\n\npop_by_quarter |&gt; \n  gt()\n\n\n\n\n\n\n\nQuarter ID\nPopulation\nHouseholds\n\n\n\n\n107\n3713876\n1122110\n\n\n108\n3654991\n1114584\n\n\n109\n3729558\n1130628\n\n\n110\n3763505\n1132368",
    "crumbs": [
      "Home",
      "Supporting materials",
      "SAM Shares Data Request"
    ]
  },
  {
    "objectID": "supporting-materials/sam-shares-data-request.html#skill-level",
    "href": "supporting-materials/sam-shares-data-request.html#skill-level",
    "title": "SAM Shares Data Request",
    "section": "Skill level",
    "text": "Skill level\nFor skill level, we will use information on schooling from pp$Education (TblShinda02), which has the following levels:\n\nIlliterate\nDo not have primary education but can read and write\nPre-primary education\nPrimary education\nLower secondary education\nUpper secondary education\nVocational education without secondary general education\nVocational education on the base of lower secondary education with secondary general education certificate\nVocational education on the base of secondary general education (except higher professional education)\nHigher professional program\nBachelor or equivalent\nMaster or equivalent\nDoctor or equivalent\n\nWe need three skill levels for our SAM template, so we map these levels to:\nLow skill (1 - 5): Illiterate through lower secondary. Medium skill (6 - 9): Upper secondary through vocational education. High skill (10 - 13): Higher professional program through Doctor.\n\npp_factor_descriptors &lt;- pp |&gt;\n  select(UID, MemberNo, Gender, Age, Education) |&gt; \n  mutate(\n    MemberId = \n      paste0(sprintf(\"%06d\", UID), sprintf(\"%02d\", MemberNo))) |&gt;\n  mutate(Gender = factor(\n    Gender,\n    levels = c(1, 2),\n    labels = c(\"Female\", \"Male\")\n  )) |&gt; \n  mutate(\n    SkillLevel = case_when(\n      Education &gt;= 0 & Education &lt;= 5 ~ 1,\n      Education &gt; 5 & Education &lt;= 9 ~ 2,\n      Education &gt; 9 & Education &lt;= 13 ~ 3,\n      TRUE ~ NA ) ) |&gt; \n  mutate(\n    SkillLevel = factor(\n      SkillLevel, \n      levels = c( 1, 2, 3),\n      labels = c( \"Low Skill\", \"Medium Skill\", \"High Skill\"))\n  )\n\nNow that we have skill levels, we need to add information on urban/rural (from hh_basics) and quintile (from ind_poverty), and type of income earner (from pp_labor).\n\nurb_rur &lt;- hh_basics |&gt; \n  select(UID, UrbanOrRural, RegNo, Weights) |&gt; \n  mutate(\n    UrbanOrRural = factor(\n      UrbanOrRural,\n      levels = c(2,1),\n      labels = c(\"Rural\", \"Urban\")\n    )\n  )\n\nquintiles &lt;- poverty |&gt; \n  select(UID, quintilc) |&gt; \n  rename(Quintile = quintilc) |&gt; \n  mutate(\n    Quintile = factor(\n      Quintile,\n      levels = c(1:5),\n      labels = c(\"Q1\", \"Q2\", \"Q3\", \"Q4\", \"Q5\")\n    )\n  )\n\npp_factor_descriptors &lt;- pp_factor_descriptors |&gt; \n  left_join(urb_rur, join_by(UID)) |&gt; \n  left_join(quintiles, join_by(UID))",
    "crumbs": [
      "Home",
      "Supporting materials",
      "SAM Shares Data Request"
    ]
  },
  {
    "objectID": "supporting-materials/sam-shares-data-request.html#labor-status-and-economic-activities",
    "href": "supporting-materials/sam-shares-data-request.html#labor-status-and-economic-activities",
    "title": "SAM Shares Data Request",
    "section": "Labor status and Economic Activities",
    "text": "Labor status and Economic Activities\nWe work with labor status from Shinda05_1. Since, upon import NACE 1 codes are converted to numbers, we need to convert them back to text, so that we can keep zeros to the left for proper order. We then extract the first two digits and match with 2-digit NACE Rev. 1 and find the correspondence to Rev. 2 from the SAM using the look-up table sam_activities. For proper order, we convert the SAM activities columns for job 1 and job 2 to factor, using the order from the dataset sam_factors.\n\npp_emstatus &lt;- pp_labor |&gt; \n  mutate(\n    MemberId = \n      paste0(sprintf(\"%06d\", UID), sprintf(\"%02d\", MemberNo))) |&gt;\n  mutate(\n    # Job 1 NACE Rev 1 code. \n    Q5  = if_else(!is.na(Q5),paste0(sprintf(\"%04d\", Q5)), NA),\n    # Job 2 NACE Rev 1 code.\n    Q12 = if_else(!is.na(Q12),paste0(sprintf(\"%04d\", Q12)), NA)) |&gt; \n  mutate(\n    job1 = if_else(!is.na(Q5),substr(Q5, 1, 2), NA),\n    job2 = if_else(!is.na(Q12),substr(Q12, 1, 2), NA)\n  ) |&gt; \n  # We match to Rev 2 and SAM classifications (for job 1 and job 2)\n  left_join(\n    sam_activities[,c(1,3)], \n    join_by(job1 == rev2_2d)) |&gt; \n  left_join(\n    sam_activities[,c(1,3)],\n    join_by(job2 == rev2_2d),\n    suffix = \n      c(\"_job1\", \"_job2\")) |&gt; \n  # And convert to factors for proper order\n  mutate(\n    SAM_job1 = factor(\n      SAM_job1, \n      levels = sam_factors$SAM,\n      # labels = sam_factors$SAM_description\n      ),\n    SAM_job2 = factor(\n      SAM_job2, \n      levels = sam_factors$SAM,\n      # labels = sam_factors$SAM_description\n      )\n  )\n\nhead(\n  pp_emstatus[c(18, 34, 40, 41, 67),\n  c(\"UID\", \"MemberNo\", \"SAM_job1\", \"SAM_job2\")]) |&gt; \n  gt()\n\n\n\n\n\n\n\nUID\nMemberNo\nSAM_job1\nSAM_job2\n\n\n\n\n386848\n1\na-trd\na-agri\n\n\n386855\n1\na-agri\na-agri\n\n\n386856\n1\na-food\na-agri\n\n\n386856\n2\na-agri\na-agri\n\n\n386866\n2\na-educ\na-educ",
    "crumbs": [
      "Home",
      "Supporting materials",
      "SAM Shares Data Request"
    ]
  },
  {
    "objectID": "supporting-materials/sam-shares-data-request.html#types-of-income",
    "href": "supporting-materials/sam-shares-data-request.html#types-of-income",
    "title": "SAM Shares Data Request",
    "section": "Types of income",
    "text": "Types of income\nBefore making our multi-dimensional tables, we need to identify different types of income. f-lab (wages) and f-surp (capital income). The instruction is that f-surp needs to be split into wages to entrepreneurs/self employed and capital income.\n\npp_emstatus &lt;- pp_emstatus |&gt; \n  mutate(\n    # We add accross three months for each source (and coalesce the NAs to 0)\n    flab_job1 = \n      rowSums(\n        across(starts_with(\"Q8_faqti_\"), \\(x) coalesce(x, 0))),\n    flab_job2 = \n      rowSums(\n        across(starts_with(\"Q14_faqti_\"), \\(x) coalesce(x, 0))),\n    fsurp = \n      rowSums(\n        across(starts_with(\"Q10_faqti_\"), \\(x) coalesce(x, 0)))\n  ) |&gt; \n  # We also add factor labels to Employment Status\n  mutate(\n    Q7 = factor(\n      Q7,\n      levels = c(1:6),\n      labels = c(\n        \"Employee\", \"Employer\", \"Own Account (Non-Ag.)\", \n        \"Own Account (Ag.)\", \"Unpaid Worker\", \"Other\"))\n    ) |&gt; \n  mutate(\n    Q13 = factor(\n      Q13,\n      levels = c(1:6),\n      labels = c(\n        \"Employee\", \"Employer\", \"Own Account (Non-Ag.)\", \n        \"Own Account (Ag.)\", \"Unpaid Worker\", \"Other\"))\n    )\n\nAnd we add our labor market variables to our pp_factor_descriptors dataset.\n\npp_emstatus &lt;- pp_emstatus |&gt;\n  select(-UID,-MemberNo) |&gt; \n  left_join(pp_factor_descriptors, join_by(MemberId)) |&gt; \n  relocate(c(UID, MemberNo, MemberId), .before = 1)",
    "crumbs": [
      "Home",
      "Supporting materials",
      "SAM Shares Data Request"
    ]
  },
  {
    "objectID": "supporting-materials/sam-shares-data-request.html#wages-and-surplus-income",
    "href": "supporting-materials/sam-shares-data-request.html#wages-and-surplus-income",
    "title": "SAM Shares Data Request",
    "section": "Wages and Surplus income",
    "text": "Wages and Surplus income\n\nflab1 &lt;- pp_emstatus |&gt; \n  select(\n    Q7, \n    UrbanOrRural, \n    Quintile, \n    SkillLevel,\n    Gender, \n    flab_job1, \n    SAM_job1, \n    Weights) |&gt;\n  filter(!is.na(flab_job1) & flab_job1 &gt; 0) |&gt; \n  rename(\n    EmStatus = Q7,\n    FLab = flab_job1,\n    SAM = SAM_job1\n  ) |&gt; \n  mutate(\n    FLab = coalesce(FLab, 0) * Weights,\n    FactorType = \"f-lab\"\n  )\n\nflab2 &lt;- pp_emstatus |&gt; \n  select(\n    Q13, \n    UrbanOrRural, \n    Quintile, \n    SkillLevel,\n    Gender, \n    flab_job2, \n    SAM_job2, \n    Weights) |&gt; \n  filter(!is.na(flab_job2) & flab_job2 &gt; 0) |&gt;\n  rename(\n    EmStatus = Q13,\n    FLab = flab_job2,\n    SAM = SAM_job2\n  ) |&gt; \n  mutate(\n    FLab = coalesce(FLab, 0) * Weights,\n    FactorType = \"f-lab\"\n  )\n\nfsurp &lt;- pp_emstatus |&gt; \n  select(\n    Q7, \n    UrbanOrRural, \n    Quintile, \n    SkillLevel,\n    Gender, \n    fsurp, \n    SAM_job1, \n    Weights) |&gt;\n  filter(!is.na(fsurp)) |&gt; \n  rename(\n    EmStatus = Q7,\n    FLab = fsurp,\n    SAM = SAM_job1\n  ) |&gt; \n  mutate(\n    FLab = coalesce(FLab, 0) * Weights,\n    FactorType = \"f-surp\"\n  )\n\nflab &lt;- rbind(flab1, flab2, fsurp)\nis.na(flab$FLab) &lt;- 0",
    "crumbs": [
      "Home",
      "Supporting materials",
      "SAM Shares Data Request"
    ]
  },
  {
    "objectID": "supporting-materials/sam-shares-data-request.html#filling-out-the-templates",
    "href": "supporting-materials/sam-shares-data-request.html#filling-out-the-templates",
    "title": "SAM Shares Data Request",
    "section": "Filling out the templates",
    "text": "Filling out the templates\nWe first get a table with all the possible combinations, so we can make sure f-lab and f-surp have the data that we need.\n\nfactor_income &lt;- flab |&gt;\n  filter(\n    as.numeric(EmStatus) &lt; 6\n  ) |&gt; \n  group_by(\n    FactorType,\n    EmStatus, \n    UrbanOrRural, \n    Quintile, \n    SkillLevel,\n    Gender) |&gt; \n  summarize(FLab = sum(FLab, na.rm = T)) |&gt; \n  ungroup() |&gt; \n  pivot_wider(\n    id_cols = c(FactorType, EmStatus, UrbanOrRural, Quintile, SkillLevel),\n    names_from = c(Gender),\n    values_from = FLab ) |&gt;\n  pivot_wider(\n    id_cols = c(FactorType, EmStatus, UrbanOrRural, Quintile),\n    names_from = c(SkillLevel),\n    values_from = c(Female, Male) ) |&gt;\n  mutate(across(5:10, ~replace_na(., 0)))\n\nSalaries from employees, salaries paid to business owners, and own account workers (mixed income).\n\nfactor_income_comprehensive &lt;- flab |&gt;\n  filter(\n    as.numeric(EmStatus) &lt; 6\n  ) |&gt; \n  group_by(\n    FactorType,\n    EmStatus, \n    UrbanOrRural, \n    Quintile, \n    SkillLevel,\n    Gender) |&gt; \n  summarize(FLab = sum(FLab, na.rm = T)) |&gt; \n  ungroup() |&gt; \n  pivot_wider(\n    id_cols = c(FactorType, EmStatus, UrbanOrRural, Quintile, SkillLevel),\n    names_from = c(Gender),\n    values_from = FLab ) |&gt;\n  pivot_wider(\n    id_cols = c(FactorType, EmStatus, UrbanOrRural, Quintile),\n    names_from = c(SkillLevel),\n    values_from = c(Female, Male) ) |&gt;\n  mutate(across(5:10, ~replace_na(., 0)))\n\n# Sneak peak\nhead(factor_income_comprehensive[,c(3:7)]) |&gt; \n  gt()\n\n\n\n\n\n\n\nUrbanOrRural\nQuintile\nFemale_Low Skill\nFemale_Medium Skill\nFemale_High Skill\n\n\n\n\nRural\nQ1\n6570741\n73766574\n40787523\n\n\nRural\nQ2\n3136840\n68728533\n61977982\n\n\nRural\nQ3\n3384631\n66745137\n62812282\n\n\nRural\nQ4\n2903820\n89122463\n101713498\n\n\nRural\nQ5\n3978437\n66745042\n211525604\n\n\nUrban\nQ1\n10106489\n140823577\n74910641\n\n\n\n\n\n\n\nNow we single out wages.\n\nfactor_income_wages &lt;- flab |&gt;\n  filter(\n    as.numeric(EmStatus) &lt; 6,\n    FactorType == \"f-lab\"\n  ) |&gt; \n  group_by( \n    UrbanOrRural, \n    Quintile, \n    SkillLevel,\n    Gender) |&gt; \n  summarize(FLab = sum(FLab, na.rm = T)) |&gt; \n  ungroup() |&gt; \n  pivot_wider(\n    id_cols = c(UrbanOrRural, Quintile, SkillLevel),\n    names_from = c(Gender),\n    values_from = FLab ) |&gt;\n  pivot_wider(\n    id_cols = c(UrbanOrRural, Quintile),\n    names_from = c(SkillLevel),\n    values_from = c(Female, Male) ) |&gt;\n  mutate(across(3:8, ~replace_na(., 0)))\n\nfactor_income_wages |&gt; \n  gt()\n\n\n\n\n\n\n\nUrbanOrRural\nQuintile\nFemale_Low Skill\nFemale_Medium Skill\nFemale_High Skill\nMale_Low Skill\nMale_Medium Skill\nMale_High Skill\n\n\n\n\nRural\nQ1\n7071449\n73976896\n40873369\n13240854\n149888608\n35772884\n\n\nRural\nQ2\n3136840\n69199593\n62840081\n21365570\n185579382\n43775774\n\n\nRural\nQ3\n3384631\n68131258\n62812282\n9797217\n181840370\n53134918\n\n\nRural\nQ4\n2903820\n89812175\n101771027\n9141381\n243339688\n104186022\n\n\nRural\nQ5\n3978437\n67394473\n213109248\n6026684\n192906975\n206728152\n\n\nUrban\nQ1\n10106489\n140832561\n74981955\n9820052\n166174929\n50228610\n\n\nUrban\nQ2\n14984587\n143794440\n180076456\n23640281\n270874403\n171555924\n\n\nUrban\nQ3\n3875826\n251290586\n353147864\n5550498\n361493523\n395323768\n\n\nUrban\nQ4\n3120367\n236333189\n531182422\n2986762\n454390332\n583664654\n\n\nUrban\nQ5\n10523005\n215233168\n1088737655\n10546093\n386107080\n1244785293\n\n\n\n\n\n\n\nAnd Capital.\n\nfactor_income_capital &lt;- flab |&gt;\n  filter(\n    as.numeric(EmStatus) &lt; 6,\n    FactorType == \"f-surp\"\n  ) |&gt; \n  group_by( \n    UrbanOrRural, \n    Quintile, \n    ) |&gt; \n  summarize(Capital = sum(FLab, na.rm = T)) |&gt; \n  ungroup()\n\nfactor_income_capital |&gt; \n  gt()\n\n\n\n\n\n\n\nUrbanOrRural\nQuintile\nCapital\n\n\n\n\nRural\nQ1\n57510741\n\n\nRural\nQ2\n77436983\n\n\nRural\nQ3\n104578879\n\n\nRural\nQ4\n124723382\n\n\nRural\nQ5\n203923504\n\n\nUrban\nQ1\n91338334\n\n\nUrban\nQ2\n172982396\n\n\nUrban\nQ3\n303575257\n\n\nUrban\nQ4\n397204825\n\n\nUrban\nQ5\n762309667\n\n\n\n\n\n\n\nAnd now, differentiated by economic activity.\n\nfactor_income_wages_activity &lt;- flab |&gt;\n  filter(\n    as.numeric(EmStatus) &lt; 6,\n    FactorType == \"f-lab\"\n  ) |&gt; \n  group_by( \n    Gender,\n    SkillLevel,\n    SAM) |&gt; \n  summarize(FLab = sum(FLab, na.rm = T)) |&gt; \n  ungroup() |&gt; \n  pivot_wider(\n    #id_cols = c(Gender, SkillLevel),\n    names_from = c(SAM),\n    names_expand = T,\n    names_sort = T,\n    values_from = FLab ) |&gt; \n  mutate(across(3:39, ~replace_na(., 0)))\n\n# factor_income_wages_activity |&gt; \n#   gt()\n\nAnd Capital.\n\nfactor_income_capital_activity &lt;- flab |&gt;\n  filter(\n    as.numeric(EmStatus) &lt; 6,\n    FactorType == \"f-surp\"\n  ) |&gt; \n  group_by( \n    SAM) |&gt; \n  summarize(\n    Capital = \"Capital\",\n    FLab = sum(FLab, na.rm = T)) |&gt; \n  ungroup() |&gt; \n  pivot_wider(\n    id_cols = c(Capital),\n    names_from = c(SAM),\n    names_expand = T,\n    names_sort = T,\n    values_from = FLab ) |&gt; \n  mutate(across(2:38, ~replace_na(., 0)))\n\n# factor_income_capital_activity |&gt; \n#   gt()",
    "crumbs": [
      "Home",
      "Supporting materials",
      "SAM Shares Data Request"
    ]
  },
  {
    "objectID": "supporting-materials/sam-shares-data-request.html#datasets-ilcs-2022",
    "href": "supporting-materials/sam-shares-data-request.html#datasets-ilcs-2022",
    "title": "SAM Shares Data Request",
    "section": "Datasets (ILCS 2022)",
    "text": "Datasets (ILCS 2022)\n\n# Household Unique ID, Weights, Location and other basic variables\nhh_basics_22 &lt;- read_dta(\n  \"data/ilcs_2022/sysschedule.dta\") |&gt;\n  mutate(\n    UID = as.integer(UID))\n\n# Household size (includes no. of family members)\nhh_size_22 &lt;- read_dta(\n  \"data/ilcs_2022/familysize.dta\")|&gt; \n  mutate(\n    UID = as.integer(UID))\n\n# Processed income at household level\nhh_income_22 &lt;- read_dta(\n  \"data/ilcs_2022/tblincomes.dta\")|&gt; \n  mutate(\n    UID = as.integer(UID))\n\n# Consumption aggregate at household level \nhh_expenditure_22 &lt;- read_dta(\n  \"data/ilcs_2022/tblexpenditures.dta\")|&gt; \n  rename(# rename total expenditure variables\n         total_expenditure = MTlianixarjebi_,\n         total_expenditure_aeq06 = MTlianimoxmareba_EqAdScale,\n         total_expenditure_aeq08 = Mtlianimoxmareba_EqAdScale_08) |&gt; \n  mutate(\n    UID = as.integer(UID))\n\n# Characteristics of the dwelling\nhh_chars_22 &lt;- read_dta(\n  \"data/ilcs_2022/tblshinda01.dta\")|&gt;\n  mutate(\n    UID = as.integer(UID))\n\n# Persons (pp)\npp_22 &lt;- read_dta(\n  \"data/ilcs_2022/tblshinda02.dta\") |&gt; \n  mutate(\n    UID = as.integer(UID),\n    MemberNo = as.integer(MemberNo))\n\n\n# Poverty\npoverty_22 &lt;- read_dta(\n  \"data/ilcs_2022/POVERTY.dta\") |&gt; \n  mutate(\n    UID = as.integer(UID))\n\nHere we have the issue that for Household Expenditures the documentation claims to use COICOP, but we have a simple 5 digit structure that doesn’t match any of the forms of COICOP. There’s a processed dataset that summarizes the following:\nTotal cash consumption expenditure - On food, beverages, tobacco - On clothing and footwear - On household goods - On health care - On fuel and electricity - On transport - On education\nOther consumption expenditure - Non-consumption cash expenditure - On agricultural activity - On transfers - On saving and lending - On property acquisition\nWe will create pivot tables out of that with the 2022 Household Survey. ## Descriptors\n\nurb_rur_22 &lt;- hh_basics_22 |&gt; \n  select(UID, UrbanOrRural, RegNo, Weights) |&gt; \n  mutate(\n    UrbanOrRural = factor(\n      UrbanOrRural,\n      levels = c(2,1),\n      labels = c(\"Rural\", \"Urban\")\n    )\n  )\n\nquintiles_22 &lt;- poverty_22 |&gt; \n  select(UID, quintilc) |&gt; \n  rename(Quintile = quintilc) |&gt; \n  mutate(\n    Quintile = factor(\n      Quintile,\n      levels = c(1:5),\n      labels = c(\"Q1\", \"Q2\", \"Q3\", \"Q4\", \"Q5\")\n    )\n  )\n\nhh_consumption_22 &lt;- hh_expenditure_22 |&gt; \n  left_join(urb_rur_22, join_by(UID)) |&gt; \n  left_join(quintiles_22, join_by(UID)) |&gt; \n  rename(\n    \"CE. Food, beverages, and tobacco\" = sursati__sasmeli__Tambaqo,\n    \"CE. Clothing and footwear\" = tansacmeli,\n    \"CE. Household goods\" = saojaxo,\n    \"CE. Health care\" = samedicino,\n    \"CE. Fuel and electricity\" = energia,\n    \"CE. Transport\" = transporti,\n    \"CE. Education\" = ganatleba,\n    \"CE. Other consumption expenditure\" = sxva,\n    \"Total cash consumption expenditure\" = samomxmXarjebi,\n    \"NC. Agricultural activity\" = sasoflo,\n    \"NC. Transfers\" = transferti,\n    \"NC. Saving and lending\" = DazogvaAnCasesxeba,\n    \"NC. Property acquisition\" = qonebis_seZena,\n    \"Non-consumption cash expenditure\" = SxvaGasavlebi,\n    \"Non-cash expenditure\" = Arafuladi_moxm_,\n    \"Cash expenditure, total\" = fuladixarjebi,\n    \"Consumption expenditure, total\" = MTlianimoxmareba_,\n  )",
    "crumbs": [
      "Home",
      "Supporting materials",
      "SAM Shares Data Request"
    ]
  },
  {
    "objectID": "supporting-materials/sam-shares-data-request.html#template",
    "href": "supporting-materials/sam-shares-data-request.html#template",
    "title": "SAM Shares Data Request",
    "section": "Template",
    "text": "Template\nFirst we pivot our expenditures longer.\n\nhh_consumption_22 &lt;- hh_consumption_22 |&gt;\n  select(\n    -c(\n      `Total cash consumption expenditure`, `Non-consumption cash expenditure`, \n      `Non-cash expenditure`, `Cash expenditure, total`, `Consumption expenditure, total`,\n      total_expenditure, total_expenditure_aeq06, total_expenditure_aeq08)) |&gt; \n  pivot_longer(\n    cols = c(\n    \"CE. Food, beverages, and tobacco\",\n    \"CE. Clothing and footwear\",\n    \"CE. Household goods\",\n    \"CE. Health care\",\n    \"CE. Fuel and electricity\",\n    \"CE. Transport\",\n    \"CE. Education\",\n    \"CE. Other consumption expenditure\",\n    \"NC. Agricultural activity\",\n    \"NC. Transfers\",\n    \"NC. Saving and lending\",\n    \"NC. Property acquisition\"\n    ),\n    names_to = \"ConsumptionCategory\", \n    values_to = \"Consumption\"\n  ) |&gt; \n  mutate(\n    ConsumptionCategory = factor(\n      ConsumptionCategory,\n      levels = c(\n        \"CE. Food, beverages, and tobacco\",\n        \"CE. Clothing and footwear\",\n        \"CE. Household goods\",\n        \"CE. Fuel and electricity\",\n        \"CE. Transport\",\n        \"CE. Education\",\n        \"CE. Health care\",\n        \"CE. Other consumption expenditure\",\n        \"NC. Agricultural activity\",\n        \"NC. Transfers\",\n        \"NC. Saving and lending\",\n        \"NC. Property acquisition\"\n      )\n    )\n  )\n\nAnd now we can fill our template.\n\nhh_consumption_pivot &lt;- hh_consumption_22 |&gt;\n  group_by( \n    ConsumptionCategory,\n    UrbanOrRural, \n    Quintile) |&gt; \n  summarize(\n    Consumption = sum((coalesce(Consumption, 0) * Weights), na.rm = T)) |&gt; \n  ungroup() |&gt; \n  pivot_wider(\n    #id_cols = c(Capital),\n    names_from = c(UrbanOrRural, Quintile),\n    names_expand = T,\n    names_sort = T,\n    values_from = Consumption )",
    "crumbs": [
      "Home",
      "Supporting materials",
      "SAM Shares Data Request"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Georgia Country Climate and Development Report",
    "section": "",
    "text": "This website contains background documents and guides created for Georgia’s World Bank Country Climate and Development Report. Authorship is indicated in each document.\n\n\n\n\n\n\n\n\nFigure 1: Map of Georgia at administrative level 1 (ADM1)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This site was created for reproducibility purposes by World Bank consultant Renato Vargas.\nContact information:\n\nE-mail: hvargasaldana [at] worldbank [dot] org\nLinkedIn: https://www.linkedin.com/in/revargas/\nWebsite: renatovargas.com"
  },
  {
    "objectID": "supporting-materials/geo-microsimulation.html",
    "href": "supporting-materials/geo-microsimulation.html",
    "title": "Georgia CCDR Microsimulation",
    "section": "",
    "text": "In this calculation file, we “age” the Georgian household survey according to demographic projections and different macroeconomic scenarios to explore the impact of climate-related risks and policy measures on the consumption expenditure distribution. It is part of a larger project with all background contributions to Georgia’s CCDR, available in this repository.\n\n# Georgia administrative level 1 shapefile\nadm1 &lt;- sf::read_sf(\"data/gis/geo-adm1.shp\") |&gt; \n  dplyr::select(ADM1_PCODE, ADM1_EN, ADM1_KA, geometry) |&gt; \n  dplyr::arrange(ADM1_PCODE)\n\ntmap::tm_shape(adm1)+\n  tmap::tm_fill(\"ADM1_EN\", legend.show = FALSE, palette = \"Set1\") +\n  tmap::tm_text(\"ADM1_EN\", size = 0.65, auto.placement = T, col = \"black\")+\n  tmap::tm_layout(frame = F)\n\n\n\n\n\n\n\nFigure 1: Map of Georgia at administrative level 1\n\n\n\n\n\nAs a convention, code is presented in the following format in this guide:\n\n# Some comment that is not evaluated by R\nsome_variable &lt;- some_function(some_object, some_parameter = TRUE)\n\nWe assume that the reader has created an Rstudio project and is familiar with basic R functions. Within that project we recommend the following file structure:\n#| eval: false\nroot/\n├── supporting-materials\n│   ├── my_script.R\n|   └── my_script.qmd\n|   └── my_script.do\n├── data/\n|   ├── my_data.sav\n|   ├── my_data.dta\n|   └── my_data.csv\n└── output\n    ├── my_output1.csv\n    └── my_output2.xlsx\nUsing RStudio project makes it possible to not use setwd() to establish the root directory and refer to subdirectories in a relative manner, making interoperability easier within teams and not hard coding a particular computer’s file structure into the code. If you are not using RStudio, just add setwd(r'(C:\\My\\path\\to\\project\\root)') at the beginning of your coding session.",
    "crumbs": [
      "Home",
      "Supporting materials",
      "Georgia CCDR Microsimulation"
    ]
  },
  {
    "objectID": "supporting-materials/geo-microsimulation.html#introduction",
    "href": "supporting-materials/geo-microsimulation.html#introduction",
    "title": "Georgia CCDR Microsimulation",
    "section": "",
    "text": "In this calculation file, we “age” the Georgian household survey according to demographic projections and different macroeconomic scenarios to explore the impact of climate-related risks and policy measures on the consumption expenditure distribution. It is part of a larger project with all background contributions to Georgia’s CCDR, available in this repository.\n\n# Georgia administrative level 1 shapefile\nadm1 &lt;- sf::read_sf(\"data/gis/geo-adm1.shp\") |&gt; \n  dplyr::select(ADM1_PCODE, ADM1_EN, ADM1_KA, geometry) |&gt; \n  dplyr::arrange(ADM1_PCODE)\n\ntmap::tm_shape(adm1)+\n  tmap::tm_fill(\"ADM1_EN\", legend.show = FALSE, palette = \"Set1\") +\n  tmap::tm_text(\"ADM1_EN\", size = 0.65, auto.placement = T, col = \"black\")+\n  tmap::tm_layout(frame = F)\n\n\n\n\n\n\n\nFigure 1: Map of Georgia at administrative level 1\n\n\n\n\n\nAs a convention, code is presented in the following format in this guide:\n\n# Some comment that is not evaluated by R\nsome_variable &lt;- some_function(some_object, some_parameter = TRUE)\n\nWe assume that the reader has created an Rstudio project and is familiar with basic R functions. Within that project we recommend the following file structure:\n#| eval: false\nroot/\n├── supporting-materials\n│   ├── my_script.R\n|   └── my_script.qmd\n|   └── my_script.do\n├── data/\n|   ├── my_data.sav\n|   ├── my_data.dta\n|   └── my_data.csv\n└── output\n    ├── my_output1.csv\n    └── my_output2.xlsx\nUsing RStudio project makes it possible to not use setwd() to establish the root directory and refer to subdirectories in a relative manner, making interoperability easier within teams and not hard coding a particular computer’s file structure into the code. If you are not using RStudio, just add setwd(r'(C:\\My\\path\\to\\project\\root)') at the beginning of your coding session.",
    "crumbs": [
      "Home",
      "Supporting materials",
      "Georgia CCDR Microsimulation"
    ]
  },
  {
    "objectID": "supporting-materials/geo-microsimulation.html#preamble",
    "href": "supporting-materials/geo-microsimulation.html#preamble",
    "title": "Georgia CCDR Microsimulation",
    "section": "2 Preamble",
    "text": "2 Preamble\nWe start with a clean environment, making sure that any objects from a previous session are not present. We take this opportunity to keep our country ISO code in a variable iso in case we need it later.\n\n# Clean workspace\nrm(list = ls())\n\n# Georgia country ISO code\niso &lt;- \"GEO\"\n\n# Survey year\nsurvey_year &lt;- 2023\n\n# Exchange rate USD per GEL\ner &lt;- 0.37\n\n# Years of interest for our macroeconomic scenario analysis\nanalysis_years &lt;- c(2030, 2050)\n\nWe call the appropriate libraries.\nRather than calling our libraries as we go, we will make sure we have everything we need from the beginning.\n\nlibrary(tidyverse) # includes dplyr, ggplot2, purr...\nlibrary(haven)     # to read SPSS and Stata datasets\nlibrary(readxl)    # to read from MS-Excel\nlibrary(openxlsx)  # to write to MS-Excel.\nlibrary(gt)        # pretty tables\nlibrary(car)       # companion to applied regression\nlibrary(modelr)    # regression models\n#library(anesrake)  \n# Raking reweighting but we don't load it, because \n# it changes the meaning of summarize from dplyr, \n# so we use the form anesrake::anesrake() when using it.\n#library(ebal)      # Entropy reweighting (not used)\nlibrary(janitor)   # pretty subtotals\nlibrary(broom)     # More regressions\nlibrary(zoo)       # Calculate moving window average and max value\n# library(ineq) # Inequality measures\n# library(acid)\n\n# Geopackages\nlibrary(sf)        # to read and write shapefile maps\nlibrary(terra)     # to perform geocalculations\nlibrary(tmap)      # for static and interactive maps",
    "crumbs": [
      "Home",
      "Supporting materials",
      "Georgia CCDR Microsimulation"
    ]
  },
  {
    "objectID": "supporting-materials/geo-microsimulation.html#datasets",
    "href": "supporting-materials/geo-microsimulation.html#datasets",
    "title": "Georgia CCDR Microsimulation",
    "section": "3 Datasets",
    "text": "3 Datasets\nWe then load the datasets that we need for this study. These are based on Georgia’s Integrated Living Conditions Survey 2022 (GEOSTAT, 2023). We take this oportunity to standardize the household identification variable to household_id.\n\n# Household size (includes no. of family members and weights)\nhh_size &lt;- read_sav(\n  \"data/ilcs_2023/familysize.sav\") %&gt;% \n  rename(household_id = UID)\n\n# Processed income at household level\nhh_income &lt;- read_sav(\n  \"data/ilcs_2023/tblincomes.sav\") %&gt;% \n  rename(household_id = UID)\n\n# Consumption aggregate at household level \nhh_expenditure &lt;- read_sav(\n  \"data/ilcs_2023/tblexpenditures.sav\") %&gt;% \n  rename(household_id = UID,\n         # rename total expenditure variables\n         total_expenditure = MTlianixarjebi_,\n         total_expenditure_aeq06 = MTlianimoxmareba_EqAdScale,\n         total_expenditure_aeq08 = Mtlianimoxmareba_EqAdScale_08)\n\n# Characteristics of the dwelling\nhh_chars &lt;- read_sav(\n  \"data/ilcs_2023/tblshinda01.sav\") %&gt;% \n  rename(household_id = UID)\n\n# Household location\nhh_location &lt;- read_sav(\n  \"data/ilcs_2023/sysschedule.sav\") %&gt;% \n  rename(household_id = UID)\n\n# Persons (pp)\npp &lt;- read_sav(\n  \"data/ilcs_2023/tblshinda02.sav\") %&gt;% \n  rename(household_id = UID)\n\n# Food diary\nfood_q &lt;- read_sav(\n  \"data/ilcs_2023/tblconsumption.sav\") %&gt;% \n  rename(household_id = UID)\n\nfood_price &lt;- read_sav( \n  \"data/ilcs_2023/tblavgprices.sav\")\n\nWe also have Continuous Labor Survey data at the individual level, which will come in handy if we do not get access to the labor part of the ILCS. See data folder for documents describing the datasets.\n\n# Labor Force Survey\nlfs_2023 &lt;- read_sav(\n  \"data/lfs_2023/LFS_ECSTAT_ENG_2023.sav\") %&gt;% \n  rename(household_id = UID)\n\n# Labor Force Survey Demographic Characteristics\nlfs_2023_dem &lt;- read_sav(\n  \"data/lfs_2023/LFS_Demographic_ENG_2023.sav\") %&gt;% \n  rename(household_id = UID)\n\nWe will work non-destructively, meaning we will not rewrite these data sets and we will only create intermediate data frame objects from them to perform transformations, selections and other data management tasks. For example, we will keep household assignment to poverty status and consumption deciles handy by creating a subset of our hh_expenditure data with only our household identifiers, deciles, and poverty if available.\n\n# We will estimate deciles from consumption\ndeciles &lt;- hh_expenditure %&gt;% \n  select( \n    # Keep household id and expenditure variables\n    household_id, \n    total_expenditure,\n    total_expenditure_aeq06, # Adult equivalent * 0.6\n    total_expenditure_aeq08) # Adult equivalent * 0.8\n\nOur population data comes from UN’s projections.\n\npopulation_projections &lt;- read_dta(\"data/population/UN2022_population.dta\") %&gt;% \n  filter(country == iso) # we filter for Georgia\n\nThe macro scenario dataset is an input provided by the Macroeconomic CGE simulation team, with yearly information on GDP, working age population, employment by economic activity (for an aggregation of three sectors: agriculture, manufacturing, and services), wages by economic activity, value added by economic activity, remittances, consumer price index, food price index and energy price index (for a bundle of gas, oil, coal, electricity) by decile (10 representative households in the macro model), and carbon tax revenue transfers to household deciles.\n\nscenario_file &lt;- \"data/ARM-Microsimulation/GEO_MacroScenarioInformation.xlsx\"\n# scenario_varlist &lt;- read_xlsx(\n#   \"data/ARM-Microsimulation/ARM_Macro_varlist.xlsx\")\n# prices_2030 &lt;- \n#   read.csv(\"data/ARM-Microsimulation/prices2030.csv\")\n\nEconomic Activities in the Survey is in Georgian. The following dataset is a lookup table with the English names.\n\n# Pending\nsectors &lt;- read_xlsx(\"data/ARM-HH-survey/economic_activity_codes.xlsx\")\n\nWe also have geographical information for level 1 in Shapefile format, which we import with the sf package. We rename the column with the name of the administrative region to match our household survey data set conventions to ease mergers. The dplyr package from the tidyverse meta package allows us to “pipe” or link processing steps using the %&gt;% pipe. Although there is no geoprocessing in this analysis, this will come in handy for graphical presentations.\n\n# Georgia administrative level 1 shapefile\nadm1 &lt;- sf::read_sf(\"data/gis/geo-adm1.shp\") |&gt; \n  dplyr::select(ADM1_PCODE, ADM1_EN, ADM1_KA, geometry) |&gt; \n  dplyr::arrange(ADM1_PCODE)\n\nAnd we plot it for reference (see Figure 2). This is done with the tmap R package and the code shown below.\n\ntmap::tm_shape(adm1)+\n  tmap::tm_fill(\"ADM1_EN\", legend.show = FALSE, palette = \"Set1\") +\n  tmap::tm_text(\"ADM1_EN\", size = 0.65, auto.placement = T, col = \"black\")+\n  tmap::tm_layout(frame = F)\n\n\n\n\n\n\n\nFigure 2: Map of Georgia at administrative level 1 (ADM1)",
    "crumbs": [
      "Home",
      "Supporting materials",
      "Georgia CCDR Microsimulation"
    ]
  },
  {
    "objectID": "supporting-materials/geo-microsimulation.html#data-preparation-income-outliers-and-missings",
    "href": "supporting-materials/geo-microsimulation.html#data-preparation-income-outliers-and-missings",
    "title": "Georgia CCDR Microsimulation",
    "section": "4 Data preparation income outliers and missings",
    "text": "4 Data preparation income outliers and missings\nWe start with various renames for standardization. Naming conventions in the guidance code use traditional abbreviations like nli for non-lablor income. We are opting for more descriptive variable names like non_labor_income, labor_income, etc. to have more easily readable code. We make an exception for total consumption (tc), because it’s a variable that we use in every scenario and it supersedes lenght limits when adding scenario identifiers.\n\n# Uncomment the correct total expenditure variable below\nex &lt;- hh_expenditure %&gt;% \n  rename(\n    tc =\n      total_expenditure\n      #total_expenditure_aeq06 # Adult equivalent * 0.6\n      #total_expenditure_aeq08 # Adult equivalent * 0.8\n      )\n\n\n4.1 Demographic characteristics, education, labor force\nHere the original code calls for Zone data, which is not present in our dataset, due to the different administrative structure of Georgia. However, we use hh_01_code (settlement) for this purpose. In the end, this variable was never used.\nDemographic data, merge with zone data Note that ed_03 (educy) below is not years of education, but education level (primary, general, secondary, etc.) However, it is ordered in a way that higher levels imply more years of education. We perform several steps within the first pipe call. The variable lstatus (Labor Force Status) here is very important for the reweigthing of the dataset later on. Note that from here onwards we will be creating _microsim versions of our datasets with the transformations needed for calculations. That way we avoid changing our original data and can refer to it later without fearing we’ve left things behind.\n\npp_microsim &lt;- pp %&gt;%\n  mutate(\n    # Demographic characteristics\n    # Unique person id\n    person_id = paste0(household_id, \"-\", str_pad(MemberNo, 2, pad = \"0\")),\n    head = ifelse(Relations == 1, 1, 0),\n    # Education level\n    educy = ifelse(is.na(Education), 0, Education),\n    # Labor Force Status\n    lstatus = case_when(\n      # 1. Employed\n      est_03 == 1 | est_04 == 1 | est_05 == 1 |\n        est_06 == 1 | est_08 == 1 ~ 1L,\n      # 2. Unemployed (available, and searching)\n      est_10 == 1 ~ 2L,\n      # 3. Inactive (available, not searching)\n      est_10 == 2 ~ 3L,\n      # Out of the labor force\n      .default = 4L # Default to OLF\n    ),\n    employed = (lstatus == 1),\n    # Salaried status (1. paid employee; 2 self-employed)\n    salaried = ifelse(\n      !is.na(emp_11a),\n      1L,\n      ifelse(is.na(emp_11a) &\n               employed == TRUE, 0L, NA_integer_)\n    )\n  ) %&gt;%\n  rename(rel = mem_03, # relationship to HH head\n         gender = mem_02,\n         age = mem_05)\n\nLater, when we conduct the reweighting of the dataset, we need to summarize into three levels of education.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(calif = case_when(\n    educy &gt;= 0 & educy &lt;= 4 ~ \"None - General\",\n    educy &gt; 3 & educy &lt;= 9 ~ \"Secondary - Vocational\",\n    educy &gt; 7 & educy &lt;= 13 ~ \"Higher +\",\n    TRUE ~ NA_character_  # Values outside the specified ranges\n  ))\n\nCount the number of employed persons by household. Note that it is necessary to explicitly tell R to ignore missing values(NA). This is different from Stata where 1 + .= 1 (where . is “missing”). In R 1 + NA = NA (where NA means “not available”). Not adding na.rm = TRUE to aggregation functions such as sum() in Listing 1 below will not throw an error and only provide a column with NA for households where at least one individidual has an employed status of NA.\n\n\n\n\nListing 1: Employed in household\n\n\n# Pending data from pp_ecstat\nhh_labor &lt;- pp_ecstat %&gt;% \n  mutate(employed = (Status == 1)) %&gt;% \n  group_by(household_id) %&gt;% \n  # Count within each household\n  mutate(employed_hh = sum(employed, na.rm = TRUE)) %&gt;%   \n  ungroup() \n\n\n\n\nHere the original Stata code calculates income variables and aggregates them by household. We skip that because the dataset ic already has these elements calculated by the WB poverty team. We’ll add them later as we need them.\nHowever, as we’ll see later labor income information is heavily non-reported in the dataset. Labor income is a crucial step in merging the dataset with macroeconomic information and so we will predict income for those that do not report it below. These variables are related to labor income, amount and frequency, which we have to standardized to a monthly or yearly value.\nPrimary and Secondary Job income:\n\nemp_11 How much was %rostertitle%’s payment for wages/salary/income for last month?\nemp_12 What period of time was the wage/income for?\nemp_25 How much was %rostertitle%’s payment for wages/salary/income for last month?\nemp_26 What period of time was the wage/income for?\n\nBonus, In-Kind, and food from job was not asked in Georgia, If it were, you should add a mutate() statement like the ones below for each subcategory in Listing 2. We use coalesce(colname, 0) when adding the annual_labor_total again to prevent sums of NA’s. This function replaces a value with 0 within the calculation if it’s missing, but doesn’t change its value permanently.\n\n\n\n\nListing 2: Annualized labor income\n\n\npp_microsim &lt;- pp_microsim %&gt;% \n  # Labor income primary job\n  mutate(annual_labor_income_primary = case_when(\n    emp_12 == 1 ~ emp_11 * 365,\n    emp_12 == 2 ~ (emp_11/7) * 365,  # Assuming weekly rate \n    emp_12 == 3 ~ (emp_11/14) * 365,\n    emp_12 == 4 ~ emp_11 * 12,\n    emp_12 == 5 ~ emp_11 * 2,\n    emp_12 == 6 ~ emp_11,\n    emp_12 == 7 ~ NA\n  ))   %&gt;% \n  # Labor income secondary job\n  mutate(annual_labor_income_secondary = case_when(\n    emp_26 == 1 ~ emp_25 * 365,\n    emp_26 == 2 ~ (emp_25/7) * 365,  # Assuming weekly rate \n    emp_26 == 3 ~ (emp_25/14) * 365,\n    emp_26 == 4 ~ emp_25 * 12,\n    emp_26 == 5 ~ emp_25 * 2,\n    emp_26 == 6 ~ emp_25,\n    emp_26 == 7 ~ NA\n  )) %&gt;% \n  # Annual labor total in thousands of dram\n  mutate(annual_labor_total = \n           (coalesce(annual_labor_income_primary, 0) + \n           coalesce(annual_labor_income_secondary, 0))/1000)\n\n# Restore annual_labor_total to NA if both NA\npp_microsim &lt;- pp_microsim %&gt;% \n  mutate(annual_labor_total =\n           if_else(\n             is.na(annual_labor_income_primary)\n             & is.na(annual_labor_income_secondary),\n         NA, \n         annual_labor_total))\n\n\n\n\nNow we need to check the share of individuals that are employed, but did not report income. This is done in Listing 3 below.\n\n\n\n\nListing 3: Employed with no income reported\n\n\ntotal_employed_no_income &lt;- pp_microsim %&gt;%\n  filter(employed == TRUE & is.na(annual_labor_total)) %&gt;% \n  nrow()\n\ntotal_employed &lt;- pp_microsim %&gt;%\n  filter(employed == TRUE) %&gt;%\n  nrow()\n\npercent_employed_no_income &lt;- \n  (total_employed_no_income / total_employed) * 100\n\nprint(\n  paste0(\n    \"There is \",\n    format(\n      percent_employed_no_income,digits = 2, nsmall=2\n      ),\n    \"% of the employed population that reports no income.\")\n  )\n\n\n\n\nWe also need to mark income outliers as those with incomes outside 5 standard deviations.\n\npp_microsim &lt;- pp_microsim  %&gt;% \n  mutate(\n    # Calculate standard deviation\n    sd = sd(annual_labor_total, na.rm = TRUE), \n    d = annual_labor_total / sd,                \n    # Combined outlier condition\n    outlier = (d &gt; 5) | (employed == TRUE & annual_labor_total == 0), \n    # Mark potential missings\n    missings = if_else(employed == TRUE, is.na(annual_labor_total), NA) \n  ) \n\nEconomic sector. The economic sectors dataset contains a lookup table for sector aggregation which we add to the pp_microsim database in Listing 4.\n\n\n\n\nListing 4: Sector aggregation\n\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(emp_04 = as.integer(emp_04)) %&gt;% \n  left_join(sectors, join_by(\"emp_04\" == \"economic_activity_code\") ) %&gt;% \n  rename(sector = ea_shortcode)\n\n\n\n\nSome individuals report no sector for either their primary or secondary job. In Listing 5 we find out the sector of other family members in their home and assign the sector of whoever is closest using fill( other_sector, .direction = \"downup\").\n\n\n\n\nListing 5: Assign sector to those who don’t report one\n\n\npp_microsim &lt;- pp_microsim %&gt;%\n  group_by(household_id) %&gt;%\n  mutate(\n    # Create a temporary variable 'other_sector'\n    # which captures the sector of any employed \n    # individual in the household\n    other_sector = \n      if_else(employed == TRUE & !is.na(sector), sector, NA_real_)\n  ) %&gt;%\n  # Use 'fill' to propagate 'other_sector' values within the household\n  fill(other_sector, .direction = \"downup\") %&gt;%\n  mutate(\n    # Impute missing 'sector' values based on the 'other_sector'\n    sector = \n      if_else(is.na(sector) & employed == TRUE, other_sector, sector)\n  ) %&gt;%\n  # Drop the temporary 'other_sector' variable\n  select(-other_sector) %&gt;%\n  ungroup()\n\n\n\n\nWe then assign a specific value for missing sectors for those employed with no one else in the hh to assign value. We select services as it’s the heaviest sector in the dataset (we do it like this, instead of say, any matching technique, because it’s only 2 observations).\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(sector = if_else(is.na(sector) & employed == TRUE, 3, sector))\n\nWe provide value labels for sector factors.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(sector_name = factor(sector, levels = c(1, 2, 3),\n                         labels = c(\"Agriculture\", \n                                    \"Manufacturing\", \n                                    \"Services\")))\n\nWe make sure that those outside the labor force (OLF) do not report a sector, which we replace with NA for those who meet the condition.\n\n\n\n\nListing 6: No sector for OLF\n\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(lstatus = as.numeric(lstatus),\n         sector = \n           if_else(lstatus == 4, \n                   as.character(NA), \n                   as.character(sector)),\n         industry = as.factor(sector)) %&gt;%\n  # We need this for reweighting and \n  # not messing up the regression below.\n  mutate(sector_w = sector)\n\n\n\n\n\n\n4.2 The regression\nSince labor income was a key variable, which we needed to match with the future wage bill by economic activity, we first checked for missing values among employed individuals. We found that almost a third of respondents (28.6%) did not report income for either their primary or secondary job. To overcome this limitation, we used the available information from the remaining respondents to estimate an extended Mincer equation, as shown in Equation 1, and implemented in Listing 7. For the respondents with available information, we also identified outliers as those outside of five standard deviations from the mean labor income.\n\\[\n\\begin{equation}\n\\begin{split}\n\\ln(lab_i) = \\\\ \\beta_0 + \\beta_1 \\text{age}_i + \\\\\n\\beta_2 \\text{gender}_i + \\beta_3 \\text{educy}_i + \\\\\n\\beta_4 \\text{age}^2_i + \\beta_5 \\text{marz}_i + \\\\\n\\beta_6 \\text{sector}_i + \\epsilon_i\n\\end{split}\n\\end{equation}\n\\tag{1}\\]\nWhere:\n\n\\(\\ln(lab_i)\\) is the natural logarithm of labor income for individual \\(i\\).\n\\(\\beta_0\\) is the intercept term.\n\\(\\beta_1, \\beta_2, \\beta_3, \\beta_4, \\beta_5, \\beta_6\\) are the coefficients for the respective independent variables.\n\\(\\text{age}_i\\) is the age of individual \\(i\\).\n\\(\\text{gender}_i\\) is a binary variable indicating the gender of individual \\(i\\) (1 for male, 2 for female).\n\\(\\text{educy}_i\\) represents the level of education for individual \\(i\\) (ordered: 1) None to General, 2) Secondary to Vocational, 3) Higher education).\n\\(\\text{age}^2_i\\) is the square of the age of individual \\(i\\), included to capture non-linear effects of age on labor income.\n\\(\\text{marz}_i\\) represents the region where individual \\(i\\) resides.\n\\(\\text{sector}_i\\) represents the sector of employment for individual \\(i\\) (i.e., agriculture, manufacturing or services).\n\\(\\epsilon_i\\) is the error term for individual \\(i\\).\n\nWe first prepare our variables for the regression.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(\n    educy2 = educy^2,\n    age2 = age^2,\n    male = case_when(\n      gender == 1 ~ 1,\n      gender == 2 ~ 0\n    ),\n    lnlab = log(annual_labor_total),\n    simuli = NA_real_ # Initialize simuli\n  )\n\nFilter the data for regression conditions.\n\nregression_data &lt;- pp_microsim %&gt;%\n  filter(employed == TRUE & outlier == FALSE & missings == FALSE)\n\nRegression model.\n\n\n\n\nListing 7: Income regression model\n\n\nmodel &lt;- lm(lnlab ~ age + gender + educy + age2 + marz + sector, \n            data = regression_data)\n\n\n\n\nPredict for specific conditions\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(\n    condition = (lstatus == 1 & (outlier == TRUE | missings == TRUE))\n  )\n\nApplying predictions.\nNote: The ‘predict’ function in R does not directly support conditions within the function call, so we handle this by filtering or subsetting the data as needed.\ntemp2 equivalent - Note: ‘type = “response”’ might be needed depending on model type.\n\npp_microsim$simuli[pp_microsim$condition==TRUE] &lt;- exp(\n  predict(model, pp_microsim[pp_microsim$condition==TRUE, ], type = \"response\"))\n\nHandling negative values in ‘simuli’.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(\n    simuli = if_else(simuli &lt; 0, 0, simuli)\n  )\n\nThere were 8 observations that met the criteria:\nWe will replace annual_labor_total with this value for those observations.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  mutate(annual_labor_total = if_else(\n    employed == TRUE & (outlier == TRUE | missings == TRUE),\n    simuli, annual_labor_total))\n\n# And get monthly incomes for everyone\npp_microsim &lt;- pp_microsim %&gt;% \n  mutate(monthly_labor_income = annual_labor_total / 12)\n\nMerging datasets.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  left_join(poverty_designations, by = \"household_id\")\n\n\n\n4.3 Total income and shares\nTotal labor income at HH level.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  group_by(household_id) %&gt;%\n  mutate(lab_hh = sum(annual_labor_total, na.rm = TRUE)) %&gt;%\n  ungroup()\n\nMonthly incomes come from the ic data set.\n\nincomes &lt;- ic %&gt;% \n  select(household_id, inc1, inc2, inc3, inc4, inc5, inc6, inc7, inc8)\n\nTotal income at HH level (the commented out portion was a less efficient way of accomplishing the same result of coalescing NAs to 0 so that the sum can be performed). Note that here we need to use the magittr pipe %&gt;% instead of the newer Native Pipe %&gt;% , because we need to reference the correct scope with the dot ..\n\npp_microsim &lt;- pp_microsim %&gt;%\n  left_join(incomes, by = c(\"household_id\" = \"household_id\")) %&gt;%\n  mutate(across(inc5:inc8, ~replace_na(., 0))) %&gt;%\n  mutate(nli_hh = 12 * rowSums(select(., inc5:inc8), na.rm = TRUE)) %&gt;%\n  mutate(income_hh = lab_hh + nli_hh)\n\n# pp_microsim &lt;- pp_microsim %&gt;%\n#   left_join(incomes, join_by(household_id == household_id)) %&gt;% \n#   mutate(nli_hh = (  coalesce(inc5) + \n#                      coalesce(inc6) +\n#                      coalesce(inc7) +\n#                      coalesce(inc8)) * 12) %&gt;% \n#   mutate(income_hh = lab_hh + nli_hh)\n\nFinal subset of data.\n\npp_microsim &lt;- pp_microsim %&gt;%\n  select(household_id, person_id, industry, salaried,\n         rural_dummy, hhsize,hhsize_R, marz_no, aepc, weight, \n         Foodpovln2022, Lpovln2022, Upovln2022, Avpovln2022, \n         poor_Foodpovln2022, poor_Lpovln2022, poor_Upovln2022, \n         poor_Avpovln2022, decile, settlement, urban_rural,\n         gender, age, head, rel, educy, calif, sector, sector_name,\n         annual_labor_total,annual_labor_income_primary,\n         annual_labor_income_secondary,monthly_labor_income,\n         lstatus, sector_w, marz.x ) %&gt;%\n  rename(marz = marz.x)\n\n# Exporting to Stata (might be necessary for reweigthing with wentropy)\n# write_dta(pp_microsim, path = \"outputs/pp_microsim.dta\", version = 10)",
    "crumbs": [
      "Home",
      "Supporting materials",
      "Georgia CCDR Microsimulation"
    ]
  },
  {
    "objectID": "supporting-materials/geo-microsimulation.html#un-population-projections",
    "href": "supporting-materials/geo-microsimulation.html#un-population-projections",
    "title": "Georgia CCDR Microsimulation",
    "section": "5 UN Population Projections",
    "text": "5 UN Population Projections\nNow we are ready to move to our demographic projections and macroeconomic model information.\nFirst, filtering based on country (our iso variable).\n\npopulation_projections &lt;- population_projections  %&gt;%  \n  filter(country == iso)\n\nCollapsing data by summing up variables starting with “yf” and “ym” and reshaping data to long format.\n\npopulation_projections &lt;- population_projections %&gt;%\n  group_by(Variant, country, cohort) %&gt;%\n  summarize(across(starts_with(c(\"yf\", \"ym\")), sum)) %&gt;%\n  ungroup()\n\npopulation_projections &lt;- pivot_longer(population_projections,\n                              cols = starts_with(c(\"yf\", \"ym\")),\n                              names_to = c(\".value\", \"year\"),\n                              names_pattern = \"(yf|ym)(.*)\")\n\nCreating new variable total_population as the sum of yf and ym. Dropping country variables.\n\npopulation_projections &lt;- population_projections %&gt;%\n  mutate(total_population = yf + ym) %&gt;%\n  select( -country) %&gt;% \n  mutate(year = as.numeric(year))\n\nSummarizing the year to find the range.\n\nminyear &lt;- survey_year # Make sure `survey_year` is correctly defined\nmaxyear &lt;- max(as.numeric(population_projections$year))\n\nWe have that the “Min Year” is minyear and the “Max Year” is maxyear. Now we create a population growth rate by demographic variant dataset. We initialize an empty list to store our data by variant and we loop over variants to create this list.\n\n# With minyear and maxyear defined above\n# Initialize a list to store growth data\npop_growth &lt;- list()\n\n# Loop over variants\nvariants &lt;- unique(population_projections$Variant)\nfor (variant in variants) {\n  for (t in minyear:maxyear) {\n    \n    # Calculate population for year t\n    pop_t &lt;- population_projections %&gt;%\n      filter(year == t, Variant == variant) %&gt;%\n      summarize(sum_pop = sum(total_population)) %&gt;%\n      pull(sum_pop)\n    \n    # Calculate population for base year\n    pop_base &lt;- population_projections %&gt;%\n      filter(year == minyear, Variant == variant) %&gt;%\n      summarize(sum_pop = sum(total_population)) %&gt;%\n      pull(sum_pop)\n    \n    # Calculate growth rate and store in list with dynamic naming\n    growth_rate &lt;- pop_t / pop_base\n    pop_growth[[paste0(t, \"_\", variant)]] &lt;- list(\n      growth_rate = growth_rate, pop_t = pop_t\n      )\n  }\n}\n\nWith the list ready, we convert back to dataframe by stitching the list elements one on top of the other.\n\n# Convert list to dataframe\npop_growth &lt;- do.call(rbind, lapply(names(pop_growth), function(x) {\n  # Extract year and variant from the name\n  parts &lt;- unlist(strsplit(x, \"_\"))\n  year &lt;- as.integer(parts[1])\n  variant &lt;- parts[2]\n  \n  # Create a tibble for each entry\n  tibble(year = year, \n         variant = variant, \n         total_population = pop_growth[[x]]$pop_t,\n         pop_growth_rate = pop_growth[[x]]$growth_rate)\n}))\n\n# Arrange the dataframe for better readability\npop_growth &lt;- arrange(pop_growth, variant, year)\n\n# Display the first few rows of the dataframe\npop_growth[c(1:09),]",
    "crumbs": [
      "Home",
      "Supporting materials",
      "Georgia CCDR Microsimulation"
    ]
  }
]